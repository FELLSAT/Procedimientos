CREATE OR REPLACE PACKAGE BODY PKG_ACOMER_PROCEDURES 
 -- =============================================      
 -- Author:  FELIPE SATIZABAL
 -- =============================================
AS
-- =============================================
-- MUESTRA LOS PEDIDOS EN COCINA
	PROCEDURE SP_ACOMER_PEDIDOS_COCINA
	(
		IN_CODIGO_COCINERO IN SEG0001.USUCED%TYPE,	-- CODIGO DEL COCINERO
		OUT_CONJUNTOS OUT SYS_REFCURSOR,			-- CONJUNTOS DE LOS PEDIDOS 
		OUT_MESA OUT SYS_REFCURSOR,					-- MESAS CON PEDIDOS
		OUT_PEDIDOS OUT SYS_REFCURSOR				-- PEDIDOS DETALLADOS DE LAS MESAS
	)
	AS
		V_CONTADOR NUMBER;	-- IDENTIFICAR QUE HAY DATOS HAY PEDIDOS 
		V_EMPRESA_COCINERO SEG0001.EMPCOD%TYPE; -- EMPRESA A LA QUE PERTENECE EL COCINERO 
		V_NUMERO_CONJUNTO NUMBER := 0;			-- NUMERO DE CONJUNOT QUE SE LE ASIGNA A LAS MESAS
	BEGIN
		-- CONSULTA EL CODIGO DE LA EMPRESA A LA QUE PERTENECE EL COCINERO
		/*SELECT EMPCOD
		INTO V_EMPRESA_COCINERO
		FROM SEG0001
		WHERE USUCED = IN_CODIGO_COCINERO;*/

		V_EMPRESA_COCINERO := '901.023.461-1';

		-- SABER SI HAY PEDIDO A ESE RESTAURANTE
		SELECT DISTINCT COUNT(B.MESCOD)
		INTO V_CONTADOR
		FROM VEN0004 A
		INNER JOIN VEN0104 B
	  		ON A.PEDNRO = B.PEDNRO
	      AND B.PEDEMPC = V_EMPRESA_COCINERO
		INNER JOIN INV00018 C
	  		ON C.MESNUMREQ = B.PEDNUMDOC  		
	  		OR C.MESNUMREQ2 = B.PEDNUMDOC  		
	  		OR C.MESNUMREQ3 = B.PEDNUMDOC  		
	  		OR C.MESNUMREQ4 = B.PEDNUMDOC  		
		WHERE A.PEDSAL = 'N';
		
		-- SI HAY MAS DE UN PLATO PARA LA COCINA 
		IF(V_CONTADOR > 0) THEN
			-- SE INSERTA LOS CODIGOS DE LA MESAS QUE TIENEN PEDIDOS ACTIVOS
			INSERT INTO TT_PEDIDOS_COCINA(
				CODIGO_MESA, HORA_PEDIDO)
			SELECT MESA, HORA
			FROM   (SELECT DISTINCT B.MESCOD MESA, B.PEDHORA HORA, B.PEDFECE
					FROM VEN0004 A
					INNER JOIN VEN0104 B
				  		ON A.PEDNRO = B.PEDNRO
				      AND B.PEDEMPC = V_EMPRESA_COCINERO
					INNER JOIN INV00018 C
				  		ON C.MESNUMREQ = B.PEDNUMDOC  		
				  		OR C.MESNUMREQ2 = B.PEDNUMDOC  		
				  		OR C.MESNUMREQ3 = B.PEDNUMDOC  		
				  		OR C.MESNUMREQ4 = B.PEDNUMDOC  		
					WHERE A.PEDSAL = 'N'
					ORDER BY B.PEDFECE, B.PEDHORA, B.MESCOD);

			DECLARE
				-- CURSOR DE LAS MESAS CON PEDIDOS EE COCINA
				CURSOR CURSOR1 IS
					SELECT CODIGO_MESA, CONJUNTO_PEDIDO
					FROM TT_PEDIDOS_COCINA;
				-- AVARIABLE DONDE SE ALMACENAN LOS DATOS QUE TRAE EL CURSOR
				CURSOR_DATA1 NUMBER;
				CURSOR_DATA2 NUMBER;
			BEGIN 
				-- ABRE EL CURSOR
				OPEN CURSOR1;
				-- CARGA LOS DATOS DE LA PRIMERA FILA 
				FETCH CURSOR1 INTO CURSOR_DATA1, CURSOR_DATA2;
				LOOP
					V_NUMERO_CONJUNTO := V_NUMERO_CONJUNTO + 1;
					-- SALE CUANDO YA NO HAY DATOS
					EXIT WHEN CURSOR1%NOTFOUND;
					-- CONUSULTA SI ES UNA MESA PRINCIPAL
					SELECT COUNT(*) 
					INTO V_CONTADOR
					FROM UNIONMESA
					WHERE MESCOD = CURSOR_DATA1
						OR MESCODUNI = CURSOR_DATA1;				
					-- SI ES UNA MESA UNIDA 
					IF(V_CONTADOR > 0 AND CURSOR_DATA2 = 0) THEN
						DECLARE
							-- MESAS QUE ESTAS UNIDAD A LA QUE SE ESTA ANALIZANDO 
							CURSOR CURSOR2 IS
									SELECT MESCOD MESA
									FROM UNIONMESA
									WHERE MESCOD = CURSOR_DATA1
										OR MESCODUNI = CURSOR_DATA1								
								UNION ALL
									SELECT MESCODUNI MESA
									FROM UNIONMESA
									WHERE MESCOD = CURSOR_DATA1
										OR MESCODUNI = CURSOR_DATA1;
							-- VARIABLE QUE CONTIENE LOS DATOS DEVUELTOS POR EL CURSOR
							CURSOR_DATA3 NUMBER;
						BEGIN
							-- SE ABRE EL CURSOR
							OPEN CURSOR2;
							-- SE CARGAN LOS DATOS DE LA FILA DEVUELTOS POR EL CURSOR
							FETCH CURSOR2 INTO CURSOR_DATA3;
							LOOP
								-- SALGA DEL LOOP CUANDO NO ENCUENTRE MAS DATOS
								EXIT WHEN CURSOR2%NOTFOUND;
								--
								UPDATE TT_PEDIDOS_COCINA
								SET CONJUNTO_PEDIDO = V_NUMERO_CONJUNTO
								WHERE CODIGO_MESA = CURSOR_DATA3;
								-- SE CARGAN LOS DATOS DE LA FILA DEVUELTOS POR EL CURSOR
								FETCH CURSOR2 INTO CURSOR_DATA3;
							END LOOP;
							CLOSE CURSOR2;

						END;

					ELSE
						BEGIN
							UPDATE TT_PEDIDOS_COCINA
							SET CONJUNTO_PEDIDO = V_NUMERO_CONJUNTO
							WHERE CODIGO_MESA = CURSOR_DATA1;
						END;
					END IF;
					-- VALORES SIGUIENTES DE LA CONSULTA
					FETCH CURSOR1 INTO CURSOR_DATA1, CURSOR_DATA2;
				END LOOP;
				CLOSE CURSOR1;

				COMMIT;

				-- SE CARGAN LOS DATOS DE LOS CONJUNTOS 
				OPEN OUT_CONJUNTOS FOR
					SELECT DISTINCT 'CONJUNTO #'||CONJUNTO_PEDIDO NOMBRE,
						CONJUNTO_PEDIDO CONJUNTO
					FROM TT_PEDIDOS_COCINA
					ORDER BY CONJUNTO_PEDIDO;

				-- SE CARGAN LOS DATOS DE LAS MESAS
				OPEN OUT_MESA FOR
					SELECT * 
					FROM TT_PEDIDOS_COCINA;

				-- SE CARGAN LOS PEDIDOS DE LAS MESAS
				OPEN OUT_PEDIDOS FOR
					SELECT PRODES PLATO, MESCOD MESA,
					      SUM(PEDCHECK) CANTIDAD, 
					      LISTAGG(TRIM(VENLINCDES),'*_') WITHIN GROUP( ORDER BY TRIM(VENLINCDES)) DESCRIPCION,
					      TRIM(CATIMG) IMAGEN, PEDNRO PEDIDO, 
					      PEDEMPC EMPRESA
					FROM (
					  	SELECT DISTINCT PRODES, MESCOD,
							PEDCHECK, VENLINCDES,
							CATIMG, PEDNRO, 
							PEDEMPC, CCOCOD
					  	FROM (
					    	SELECT D.PRODES, B.MESCOD,
					        	A.PEDCHECK, D.VENLINCDES,
					        	E.CATIMG, A.CCOCOD,
					        	A.PEDNRO, A.PEDEMPC
					    	FROM VEN0004 A
					    	INNER JOIN VEN0104 B
					      		ON A.PEDNRO = B.PEDNRO
					      		AND B.PEDEMPC = V_EMPRESA_COCINERO
					    	INNER JOIN INV00018 C
					      		ON C.MESNUMREQ = B.PEDNUMDOC  		
								OR C.MESNUMREQ2 = B.PEDNUMDOC  		
								OR C.MESNUMREQ3 = B.PEDNUMDOC  		
								OR C.MESNUMREQ4 = B.PEDNUMDOC  		
					    	INNER JOIN VEN0001 D
					        	ON D.PROCOD = A.PEDPROCOD
					    	INNER JOIN INV0013 E
					        	ON E.CATECOD = D.VENCATCOD
					    	WHERE A.PEDSAL = 'N'
					    	ORDER BY B.PEDFECE, B.PEDHORA, B.MESCOD))
					GROUP BY PRODES, MESCOD,
					      TRIM(VENLINCDES),
					      TRIM(CATIMG), PEDNRO, 
					      PEDEMPC;      
			END;

		ELSE 

			BEGIN
				-- SE INDICA QUE EL RESTAURANTE NO TIENE PEDIDOS A MESA
				OPEN OUT_CONJUNTOS FOR
					SELECT DISTINCT 'SIN PEDIDOS' NOMBRE,
						'SIN PEDIDOS' CONJUNTO
					FROM DUAL;

				-- SE INDICA QUE EL RESTAURANTE NO TIENE PEDIDOS A MESA
				OPEN OUT_MESA FOR
					SELECT 'SIN PEDIDOS' CODIGO_MESA,
						'SIN PEDIDOS' CONJUNTO_PEDIDO,
						'SIN PEDIDOS' HORA_PEDIDO
					FROM DUAL;

				-- SE INDICA QUE EL RESTAURANTE NO TIENE PEDIDOS A MESA
				OPEN OUT_PEDIDOS FOR
					SELECT 'SIN PEDIDOS' PLATO,
						'SIN PEDIDOS' MESA,
						'SIN PEDIDOS' CANTIDAD,
						'SIN PEDIDOS' DESCRIPCION,
						'SIN PEDIDOS' IMAGEN,					
					  	'SIN PEDIDOS' PEDIDO				  	
					FROM DUAL;
			END;
		END IF;
	END SP_ACOMER_PEDIDOS_COCINA;

-- =============================================
-- INDICAR QUE EL PEDIDOS YA ESTA LISTO PARA ENTREGAR
	PROCEDURE SP_ACOMER_ENTREGA_PEDIDO
	(
		IN_CODIGO_EMPRESA VEN0004.PEDEMPC%TYPE, -- CODIGO DE LA EMPRESA A LA QUE PERTENECE EL PLATO
		IN_CODIGO_PEDIDO VEN0004.PEDNRO%TYPE,	-- CODIGO DE PEDIDO QUE SE LE ASIGNA AL PLATO
		IN_NOMBRE_PLATO VEN0004.PEDPROCOD%TYPE	-- CODIGO DEL PLATO QUE SE ESTA ENTREGANDO	
	)
	AS
		V_CODIGO_PLATO VEN0001.PROCOD%TYPE; -- CODIGO DEL PLATO QUE SE VA A ENTREGAR
	BEGIN
		-- CONSULTA EL CODIGO DEL PLATO QUE SE INDICA YA ESTA LISTO PARA ENTREGAR
		SELECT PROCOD
		INTO V_CODIGO_PLATO
		FROM VEN0001
		WHERE PRODES = IN_NOMBRE_PLATO;		
		
		-- ACTUALIZA EL PEDIDO ESPECIFICO 
		UPDATE VEN0004
		SET PEDCHECK = 0,
			PEDSAL = 'T'
		WHERE PEDEMPC = IN_CODIGO_EMPRESA
			AND PEDNRO = IN_CODIGO_PEDIDO
			AND PEDPROCOD = V_CODIGO_PLATO;
			
		COMMIT;
	END SP_ACOMER_ENTREGA_PEDIDO;

-- =============================================
-- CATEGORIAS Y PLATOS QUE TIENE LOS 4 CONTAINERS
	PROCEDURE SP_ACOMER_MENU
	(
		CURSOR_CATEGORIAS OUT SYS_REFCURSOR,    -- CURSOR QUE TENDRA LOS DATOS DE  LAS CATEGORIAS DE COMIDAS
		CURSOR_SUBCATEGORIAS OUT SYS_REFCURSOR, -- CURSOR QUE TENDRA LOS DATOS DE LAS SUBCATEGORIAS DE COMIDAS
		CURSOR_TERMINOS OUT SYS_REFCURSOR,      -- CURSOR QUE TENDRA LOS DATOS DE LOS TERMINOS DE LA COMIDA EN CASO DE TENERLOS
		CURSOR_COMIDA OUT SYS_REFCURSOR			-- CRUSRO QUE TENDRA LOS DATOS DE CADA UNO DE LAS COMIDAD OFRECIDAS
	)
	AS
	BEGIN
	-- =============================================
	-- CATEGORIAS DE LAS COMIDAS
		OPEN CURSOR_CATEGORIAS FOR
			SELECT DISTINCT TRIM(CATECOD) COD_CATEGORIA,
				TRIM(CATEDES) DESCRIPCION,
				TRIM(CATIMG) IMAGEN
			FROM INV0013 
			WHERE CATEEMPCOD = PKG_CONTAINER1
				OR CATEEMPCOD = PKG_CONTAINER2
				OR CATEEMPCOD = PKG_CONTAINER3
				OR CATEEMPCOD = PKG_CONTAINER4
			ORDER BY COD_CATEGORIA;

	-- =============================================
	-- SUBCATEGORIAS DE LAS COMIDAS
		OPEN CURSOR_SUBCATEGORIAS FOR
			SELECT DISTINCT TRIM(CATECOD) COD_CATEGORIA,
				TRIM(SUBCATECOD) COD_SUBCATEGORIA,
				TRIM(SUBCATEDES) DESCRIPCION
			FROM INV0014
			WHERE CATEEMPCOD = PKG_CONTAINER1
				OR CATEEMPCOD = PKG_CONTAINER2
				OR CATEEMPCOD = PKG_CONTAINER3
				OR CATEEMPCOD = PKG_CONTAINER4
			ORDER BY COD_CATEGORIA, COD_SUBCATEGORIA;
			

	-- =============================================
	-- TERMINOS DE LAS COMIDAS
		OPEN CURSOR_TERMINOS FOR
			SELECT  DISTINCT TRIM(CATECOD) COD_CATEGORIA,
				TRIM(SUBCATECOD) COD_SUBCATEGORIA, 
				SUBSTR(TRIM(LINCODCATE),0,LENGTH(TRIM(LINCODCATE))-1) COD_TERMINO,
				TRIM(LINDESCATE) TERMINOS
			FROM INV0015
			WHERE CATEEMPCOD = PKG_CONTAINER1
				OR CATEEMPCOD = PKG_CONTAINER2
				OR CATEEMPCOD = PKG_CONTAINER3
				OR CATEEMPCOD = PKG_CONTAINER4
				-- ADICIONAR LAS DEMAS CODIGOS DE LOS RESTUARANTES QUE OFRECEN
			ORDER BY COD_CATEGORIA, COD_SUBCATEGORIA, COD_TERMINO;

	-- =============================================
	-- TERMINOS DE LAS COMIDAS
		OPEN CURSOR_COMIDA FOR
			SELECT DISTINCT TRIM(A.PRECIO) PRECIO, 
	            TRIM(A.COD_PRODUCTO) COD_PRODUCTO,
	            TRIM(B.PRODES) NOMBRE, 
	            TRIM(B.VENCATCOD) CATEGORIA,
	            TRIM(B.VENSCATCOD) SUB_CATEGORIA, 
	            NVL(B.VENLINCCOD, 'SIN_TERMINO') TERMINOS
	        FROM (	SELECT MAX(A.PROPRE) PRECIO,
		                A.PROCOD COD_PRODUCTO	                
		            FROM VEN00012 A
		            WHERE A.VENEMPC = PKG_CONTAINER1
		            	OR A.VENEMPC = PKG_CONTAINER2
		            	OR A.VENEMPC = PKG_CONTAINER3
		            	OR A.VENEMPC = PKG_CONTAINER4
		            GROUP BY A.PROCOD) A
	        LEFT JOIN VEN0001 B
	            ON A.COD_PRODUCTO = B.PROCOD
	        ORDER BY CATEGORIA, SUB_CATEGORIA,TERMINOS;

	END SP_ACOMER_MENU;	

-- =============================================
-- PUESTOS QUE HAY POR FACTURAR EN LA NES
	PROCEDURE SP_aCOMER_FACTURA_PUESTOS
	(
		IN_CODIGO_MESA IN VEN0104.MESCOD%TYPE, -- CODIGO DE LA MESA
		OUT_CURSOR_PUESTOS OUT SYS_REFCURSOR   -- CURSOR CON LOS PUESTOS QUE FALTAN POR FACTURAR
	)
	AS 
	BEGIN
		OPEN OUT_CURSOR_PUESTOS FOR
	 	SELECT DISTINCT SUBSTR(CCOCOD,2)  CCOCOD
		FROM VEN0004 A
		INNER JOIN VEN0104 B
		    ON A.PEDNRO = B.PEDNRO
		    AND B.MESCOD = IN_CODIGO_MESA
		WHERE PEDSAL NOT IN ('F','C')
		    ORDER BY CCOCOD; 
	END SP_aCOMER_FACTURA_PUESTOS;

-- =============================================
-- FACTURACION DE UNA MESA
	PROCEDURE SP_ACOMER_FACTURACION
	(
		IN_CEDULA_CLIENTE IN VEN0104.PCLICOD%TYPE,  -- CEDULA DEL CLINETE QUE VA A FACTURAR
		IN_NOMBRE_COMPLETO IN VEN0104.PCLINOM%TYPE, -- NOMBRE COMPLETO DEL CLIENTE
		IN_CODIGO_MESA IN VEN0104.MESCOD%TYPE, 		-- CODIGO DE LA MESA DEL PEDIDO 
		IN_CELULA_MESERO IN SEG0001.USUCED%TYPE,    -- CEDULA DEL MESERIO
		IN_FORMA_PAGO VEN0104.PFPGCOD%TYPE,      	-- FORMA DE PAGO
		IN_PUESTOS_ARRAY IN TYPE_PEDIDOS_ARRAY,		-- PUESTOS QUE SE VAN A FACTURAR
		OUT_CURSOR_FACTURA OUT SYS_REFCURSOR,		-- CURSOR CON LOS DATOS DE LA CABECERA DE FACTURA
		OUR_CURSOR_FACTURA_C OUT SYS_REFCURSOR,     -- CURSOR PARA EL DETALLE DE LA FACTURA
		OUT_TOTAL_PAGAR OUT NUMBER 					-- TOTAL A PAGAR 
	)
	AS
		V_TAMANO NUMBER;					   -- TAMANO DEL ARRAY DE LOS PUESTO 
		V_PRECIO_CLIENTE GEN0024.LIPCOD%TYPE;  -- PRECIO QUE SE LE ESTABLECE AL CLIENTE		
		V_ULTIMA_FACTUACION NUMBER := 0;       -- SABER SI SE CIERRAMESA O NO
		V_NUM_FACGRAL CAB_FACTURA_GRAL.FACNROGRAL%TYPE;  -- NUMERO DE LA FACTURA GENERAK
		V_FACNRO_CAB_DET VEN0008.FACNRO%TYPE;			 -- NUMERO DE FACTURA QUE SE LE ASIGNA
	BEGIN
		-- ===================================
		--  IDENTIFICAR SI SE VA A FACTURAR EN UNA SOLA FACTURA O EN DIFERENTES FACTURAS
		BEGIN
			V_TAMANO := TO_NUMBER(IN_PUESTOS_ARRAY(1));
		EXCEPTION
			WHEN OTHERS THEN 
				V_TAMANO := 0;
		END;
		
		-- SI EL TAMANO DEL ARRAY ES 0 SE GENERA UNA SOLA FACTURA 
		IF (V_TAMANO = 0) THEN
			BEGIN		
				-- ===================================
				-- VERIFICA EL PRECIO QUE SE LE DEBE COBRAR AL CLIENTE
				BEGIN
					-- VERIFICA QUE EL CLIENTE ESTE REGISTRADO Y TENGA PRECIO ESPECIAL PARA REALIZAR CAMBIOS
					SELECT LIPCOD
					INTO V_PRECIO_CLIENTE
					FROM GEN0024 A
					LEFT JOIN GEN0003 B 
					  	ON A.CLIPAICOD = B.PAICOD 
					  	AND A.CLIDPTCOD = B.DPTCOD 
					  	AND A.CLIMPOCOD = B.MPOCOD  
					WHERE A.CLICOD= IN_CEDULA_CLIENTE 
						AND A.SUCTERCOD='01';
				EXCEPTION 
					WHEN NO_DATA_FOUND THEN 
						V_PRECIO_CLIENTE := '01';
				END;

				-- ===================================						
				-- SE EJECUTA LA LOGICA DE LA FACTURACION PARA TODO LA MESA
				DECLARE
					V_CEDULA_CLIENTE VEN0104.PCLICOD%TYPE;   -- CEDULA DEL CLIENTE 
					V_CODIGO_MESA VEN0104.MESCOD%TYPE;		 -- MESA DEL PEDIDO			
					V_NOMBRE_COMPLETO VEN0104.PCLINOM%TYPE;  -- NOMBRE COMPLETO DEL CLIENTE		
					V_FORMA_PAGO VEN0104.PFPGCOD%TYPE;       -- FORMA DE PAGOS				
					V_PUESTOS_ARRAY TYPE_PEDIDOS_ARRAY;
					ARRAY_PEDIDOS TYPE_PEDIDOS_ARRAY; -- ARRAY CON LOS CODIGOS DE LOS PEDIDOS DE LA MESA
					ARRAY_EMPRESA TYPE_PEDIDOS_ARRAY; -- ARRAY CON LOS CODIGOS DE LAS EMPRESAS DE LOS PEDIDOSA
				BEGIN
				 	-- ==========================					
					-- ASIGNO LOS VALORES CORRESPONDIENTES PARA LOS PARAMETROS DE LA ACTUALIZACION DE PRECIOS
					V_CEDULA_CLIENTE := IN_CEDULA_CLIENTE;
					V_NOMBRE_COMPLETO := IN_NOMBRE_COMPLETO;
					V_CODIGO_MESA := IN_CODIGO_MESA;										
					V_FORMA_PAGO := IN_FORMA_PAGO;
					V_PUESTOS_ARRAY := IN_PUESTOS_ARRAY;

					-- ==========================
					-- SE CONSULTA LOSNUMERO DE LOS PEDIDOS QUE TENGA LA MESA EN CADA RESTAURANTE
					SELECT NVL(MESNUMREQ,'NULL'), 
						NVL(MESNUMREQ2,'NULL'),
					    NVL(MESNUMREQ3,'NULL'), 
					    NVL(MESNUMREQ4,'NULL'),
					    PKG_CONTAINER1,PKG_CONTAINER2,
					    PKG_CONTAINER3,PKG_CONTAINER4
					INTO ARRAY_PEDIDOS(0), ARRAY_PEDIDOS(1),
						ARRAY_PEDIDOS(2), ARRAY_PEDIDOS(3),
						ARRAY_EMPRESA(0), ARRAY_EMPRESA(1),
						ARRAY_EMPRESA(2), ARRAY_EMPRESA(3)
					FROM INV00018
					WHERE MESCOD = IN_CODIGO_MESA;

					-- ============================
					-- LLENAR LA TABLA CON LOS NUMERO DE 
					FOR I IN ARRAY_PEDIDOS.FIRST..ARRAY_PEDIDOS.LAST
					LOOP
						-- SI ESDIFERENTE DE NULO NO SE INSERTA
						IF(ARRAY_PEDIDOS(I) <> 'NULL') THEN
							INSERT INTO TT_FACTURA_DOCUMENTOS
							(NUMERO_DOC,CODIGO_EMP)
							VALUES(CAST(ARRAY_PEDIDOS(I) AS CHAR(10)),CAST(ARRAY_EMPRESA(I) AS CHAR(13)));
						END IF;
					END LOOP;

					-- ==========================		
					-- SI EL TIPO DE PRECIO ES 01 SE PROCEDE A FACTURAR 	
					IF(V_PRECIO_CLIENTE <> '01') THEN
						--SE ACTUALIZAN LOS PRECIOS DE LOS PEDIDOS					
						SP_ACOMER_FACTURACION_ACT(V_PRECIO_CLIENTE,V_CODIGO_MESA,V_PUESTOS_ARRAY);
					END IF;

					-- ==========================
					-- SE RECORRE LOS PEDIDOS PARA ACTUALIZAR EL PEDIDO CON LOS DATOS DEL CLIENTES
					FOR I IN ARRAY_PEDIDOS.FIRST..ARRAY_PEDIDOS.LAST
					LOOP
						-- SI ES NULL NO TIENE PEDIDO EN EL RESTAURANTE X
						IF(ARRAY_PEDIDOS(I) <> 'NULL') THEN 
							-- SI NO ESTA REGISTRADO
							IF(V_PRECIO_CLIENTE <> '01') THEN
								--SE ACTUAIZA LA INFORMACION DEL CLIENTE EN EL PEDIDO 
								SP_ACOMER_ACT_PEDIDO_CLI(1,V_CEDULA_CLIENTE,V_NOMBRE_COMPLETO,V_FORMA_PAGO,ARRAY_EMPRESA(I),ARRAY_PEDIDOS(I));
							ELSE
								--SE ACTUAIZA LA INFORMACION DEL CLIENTE EN EL PEDIDO 
								SP_ACOMER_ACT_PEDIDO_CLI(0,V_CEDULA_CLIENTE,V_NOMBRE_COMPLETO,V_FORMA_PAGO,ARRAY_EMPRESA(I),ARRAY_PEDIDOS(I));
							END IF;
						END IF;
					END LOOP;

					-- ==========================
					--SE EJECUTA EL PROCEDIMIWNTO DE FACTURACION
					FOR I IN ARRAY_PEDIDOS.FIRST..ARRAY_PEDIDOS.LAST
					LOOP
						-- SI ES NULL NO TIENE PEDIDO EN EL RESTAURANTE X
						IF(ARRAY_PEDIDOS(I) <> 'NULL') THEN 
							--GENERA LA FACTURACIOIN PARA LOSD PEDIDO EN CADA RESTAURANTE
							SP_ACOMER_FACTURACION_CAB_DET('PD','169',ARRAY_EMPRESA(I),ARRAY_PEDIDOS(I),V_CEDULA_CLIENTE,V_CODIGO_MESA,V_FACNRO_CAB_DET);
						END IF;
					END LOOP;		

					-- =========================
					-- SE LIBERA LA MESA 		
					SP_ACOMER_FACTURA_MESA_FIN(V_CODIGO_MESA, 0);
				END;		
			END;
		ELSE
			BEGIN
				DECLARE
					V_NUMERO_PEDIDO1 INV00018.MESNUMREQ%TYPE; -- CODIGO DEL PEDIDO EN RESTAURANTE 1
					V_NUMERO_PEDIDO2 INV00018.MESNUMREQ2%TYPE; -- CODIGO DEL PEDIDO EN RESTAURANTE 2
					V_NUMERO_PEDIDO3 INV00018.MESNUMREQ3%TYPE; -- CODIGO DEL PEDIDO EN RESTAURANTE 3
					V_NUMERO_PEDIDO4 INV00018.MESNUMREQ4%TYPE; -- CODIGO DEL PEDIDO EN RESTAURANTE 4
					V_CONTADOR1 NUMBER;	-- CONTADOR DE PEDIDOS EN LA MESA				
					V_CEDULA_CLIENTE VEN0104.PCLICOD%TYPE;   -- CEDULA DEL CLIENTE 
					V_CODIGO_MESA VEN0104.MESCOD%TYPE;		 -- MESA DEL PEDIDO			
					V_NOMBRE_COMPLETO VEN0104.PCLINOM%TYPE;  -- NOMBRE COMPLETO DEL CLIENTE		
					V_FORMA_PAGO VEN0104.PFPGCOD%TYPE;       -- FORMA DE PAGOS				
					V_PUESTOS_ARRAY TYPE_PEDIDOS_ARRAY;
				BEGIN	
					-- ==========================					
					-- ASIGNO LOS VALORES CORRESPONDIENTES PARA LOS PARAMETROS DE LA ACTUALIZACION DE PRECIOS
					V_CEDULA_CLIENTE := IN_CEDULA_CLIENTE;
					V_NOMBRE_COMPLETO := IN_NOMBRE_COMPLETO;
					V_CODIGO_MESA := IN_CODIGO_MESA;										
					V_FORMA_PAGO := IN_FORMA_PAGO;
					V_PUESTOS_ARRAY := IN_PUESTOS_ARRAY;

					-- ===================================
					-- VERIFICA EL PRECIO QUE SE LE DEBE COBRAR AL CLIENTE
					BEGIN
						-- VERIFICA QUE EL CLIENTE ESTE REGISTRADO Y TENGA PRECIO ESPECIAL PARA REALIZAR CAMBIOS
						SELECT LIPCOD
						INTO V_PRECIO_CLIENTE
						FROM GEN0024 A
						LEFT JOIN GEN0003 B 
						  	ON A.CLIPAICOD = B.PAICOD 
						  	AND A.CLIDPTCOD = B.DPTCOD 
						  	AND A.CLIMPOCOD = B.MPOCOD  
						WHERE A.CLICOD= IN_CEDULA_CLIENTE 
							AND A.SUCTERCOD='01';
					EXCEPTION 
						WHEN NO_DATA_FOUND THEN 
							V_PRECIO_CLIENTE := '01';
					END;

					-- ==========================		
					-- SI EL TIPO DE PRECIO ES 01 SE PROCEDE A FACTURAR 	
					IF(V_PRECIO_CLIENTE <> '01') THEN
						--SE ACTUALIZAN LOS PRECIOS DE LOS PEDIDOS					
						SP_ACOMER_FACTURACION_ACT(V_PRECIO_CLIENTE,V_CODIGO_MESA,V_PUESTOS_ARRAY);
					END IF;

					-- =========================
					-- TENER EN UNA TABLA TODOS LOS PUESTOS QUE SE FACTURAN
					FOR I IN IN_PUESTOS_ARRAY.FIRST..IN_PUESTOS_ARRAY.LAST 
					LOOP
						-- INSERTA EN LA TABLA TEMPORAL TODOS LOS PUESTOS QUE VA A FACTURAR
						INSERT INTO TT_PUESTOS_FACTURA (CODIGO_PUESTO)
						VALUES (CAST(IN_PUESTOS_ARRAY(I) AS CHAR(3)));
					END LOOP;

					-- =======================
					-- 
					DECLARE
						CV_EMPRESA VEN0104.PEDEMPC%TYPE; -- ALMACENA LOS DATOS DEL CURSOR
						CV_CODIGO_PED VEN0104.PEDNUMDOC%TYPE;   -- ALMACENA LOS DATOS DEL CURSOR
						-- CODIGO DEL PEDIDO DONDE ESTA EL PUESTO Y LA EMPRESA A LA QUE PERTENECE
						CURSOR CUR_PEDIDOS_PUESTO IS
							SELECT DISTINCT PEDNUMDOC, A.PEDEMPC
							FROM VEN0104 A
							INNER JOIN VEN0004 B
							    ON B.PEDNRO = A.PEDNRO    
							    AND B.CCOCOD IN (SELECT * FROM TT_PUESTOS_FACTURA)
							    AND B.PEDSAL NOT IN ('F')
							WHERE A.MESCOD = V_CODIGO_MESA;						    
					BEGIN
						-- =======================
						-- RECORRER EL CURSOR
						OPEN CUR_PEDIDOS_PUESTO;
					    FETCH CUR_PEDIDOS_PUESTO INTO CV_CODIGO_PED, CV_EMPRESA;
					    WHILE CUR_PEDIDOS_PUESTO%FOUND 
					    LOOP			
					    	-- CANTIDAD DE PEDIDOS CON ESE CODIGO 
					    	SELECT COUNT(A.CCOCOD)
					    	INTO V_CONTADOR1
							FROM VEN0004 A
							INNER JOIN VEN0104 B
							    ON B.PEDNRO = A.PEDNRO    
							    AND B.PEDNUMDOC IN (CV_CODIGO_PED);

							IF(V_CONTADOR1 > 1) THEN
								BEGIN
									DECLARE 
										V_DOCUMENTO_PEDIDO_NEW GEN0012.DOCNRO%TYPE; -- NUMERO DE DOCUMENTO PEDIDO NUEVO 
										V_NUMERO_PEDIDO_NEW VEN0104.PEDNRO%TYPE;	-- NUMERO DE PEDIDO NUEVO 
										V_NUMERO_PEDIDO_OLD VEN0104.PEDNRO%TYPE;	-- NUMERO DE PEDIDO VIEJO 
									BEGIN
										-- CONSULTANUMERO DEL DOCUMENTO DE PEDIDO DEL RESTAURANTE
										SELECT TO_NUMBER(GEN0012.DOCNRO + 1)
										INTO V_DOCUMENTO_PEDIDO_NEW
										FROM GEN0012
										WHERE GEN0012.DOCCOD = 'PD'
											AND GEN0012.EMPPAIC = '169'
											AND GEN0012.EMPCOD = CV_EMPRESA;	

										-- SE ACTUALIZA EL NUMERO DE DOCUMENTO DEL PEDIDO 
										UPDATE GEN0012
											SET  DOCNRO = V_DOCUMENTO_PEDIDO_NEW
										WHERE GEN0012.DOCCOD = 'PD'
											AND GEN0012.EMPPAIC = '169'
											AND GEN0012.EMPCOD = CV_EMPRESA;

										-- SE INSERTA EN LA TABLA LOS NUMEROS DE DOCUMETNO QUE SE HAN GENERADO
										INSERT INTO TT_DOCU_NUM_PED
										(NEW_ODC_NUM)
										VALUES (V_DOCUMENTO_PEDIDO_NEW);

										-- SE CONSULTA EL MAXIMO 
										SELECT NVL(MAX(PEDNRO),0) + 1
										INTO V_NUMERO_PEDIDO_NEW
										FROM VEN0104;

										-- SE INSERTA LA CABECERA DEL PEDIDO 
										INSERT INTO VEN0104(
											PEDPAIC, PEDEMPC,
											PEDCODDOC, PEDNRO,
											PEDNUMDOC, PEDFECH,
											PEDFECE, COTPAIC,
											COTEMPC, PEDVENCOD,
											PEDFAC, PEDLC,
											PEDDEDT, PEDFLE,
											PEDMODCOD, PEDORDCOM,
											PEDOTM, PEDTDEOM,
											USUPAIC, USUEMPC,
											VENUSUARIO, PEDHORA,
											MESCOD)
										SELECT DISTINCT B.PEDPAIC, B.PEDEMPC,
									        B.PEDCODDOC, V_NUMERO_PEDIDO_NEW,
									        V_DOCUMENTO_PEDIDO_NEW, B.PEDFECH,
									        B.PEDFECE, B.COTPAIC,
									        B.COTEMPC, B.PEDVENCOD,
									        B.PEDFAC, B.PEDLC,
									        B.PEDDEDT, B.PEDFLE,
									        B.PEDMODCOD, B.PEDORDCOM,
									        B.PEDOTM, B.PEDTDEOM,
									        B.USUPAIC, B.USUEMPC,
									        B.VENUSUARIO, B.PEDHORA,
									        B.MESCOD
									    FROM VEN0004 A
									    INNER JOIN VEN0104 B
									        ON B.PEDNRO = A.PEDNRO  
									        AND B.PEDNUMDOC IN (CV_CODIGO_PED)
									        AND B.PEDEMPC IN (CV_EMPRESA)
									    WHERE A.CCOCOD IN (SELECT * FROM TT_PUESTOS_FACTURA);

									    -- SE INSERTA LA CABECERA DEL NUEVO PEDIDO
									    INSERT INTO VEN0004(
									    	PEDPAIC, PEDEMPC,
											PEDCODDOC, PEDNRO,
											PEDLIN, PEPC,
											PEC, PEDPROCOD,
											CCOCOD, PEDUNI,
											PEDVAL, PEDVALCPI,
											PEDPORIVA, PEDVALIVA,
											PEDVALTUN, PEDPORDC,
											PEDDCVAL, PEDSUCDET,
											PEDALIAS, PEDCHECK,
											PEDSAL)
									    SELECT A.PEDPAIC, A.PEDEMPC,
									        A.PEDCODDOC, V_NUMERO_PEDIDO_NEW,
									        A.PEDLIN, A.PEPC,
									        A.PEC, A.PEDPROCOD,
									        A.CCOCOD, A.PEDUNI,
									        A.PEDVAL, A.PEDVALCPI,
									        A.PEDPORIVA, A.PEDVALIVA,
									        A.PEDVALTUN, A.PEDPORDC,
									        A.PEDDCVAL, A.PEDSUCDET,
									        A.PEDALIAS, A.PEDCHECK,
									        A.PEDSAL
									    FROM VEN0004 A
									    INNER JOIN VEN0104 B
									        ON B.PEDNRO = A.PEDNRO  
									        AND B.PEDNUMDOC IN (CV_CODIGO_PED)
									        AND B.PEDEMPC IN (CV_EMPRESA)
									    WHERE A.CCOCOD IN (SELECT * FROM TT_PUESTOS_FACTURA);
	    
									    -- CONSULTO EL NUMERO DE PEDIDO QUE TENIA 								    
									    SELECT DISTINCT A.PEDNRO
									    INTO V_NUMERO_PEDIDO_OLD
									    FROM VEN0004 A
									    INNER JOIN VEN0104 B
									        ON B.PEDNRO = A.PEDNRO  
									        AND B.PEDNUMDOC IN (CV_CODIGO_PED)
									        AND B.PEDEMPC IN (CV_EMPRESA)
									    WHERE A.CCOCOD IN (SELECT * FROM TT_PUESTOS_FACTURA);

									    -- ELIMINAMOS EL DETALLE DE ESTE PUESTO 
									    DELETE FROM VEN0004
									    WHERE CCOCOD IN (SELECT * FROM TT_PUESTOS_FACTURA)
									        AND PEDEMPC IN (CV_EMPRESA)
									        AND PEDNRO = V_NUMERO_PEDIDO_OLD;

									    -- INSERTA LOS DATOS DE LA FACTURACION 
									    INSERT INTO TT_FACTURA_DOCUMENTOS
									    	(NUMERO_DOC, CODIGO_EMP)
									    VALUES (V_DOCUMENTO_PEDIDO_NEW, CV_EMPRESA);

									    -- SE ACTUALIZA LA INFORMACION DEL CLIENTE
									    IF(V_PRECIO_CLIENTE <> '01') THEN
									    	SP_ACOMER_ACT_PEDIDO_CLI(1,V_CEDULA_CLIENTE,V_NOMBRE_COMPLETO,V_FORMA_PAGO,CV_EMPRESA,V_DOCUMENTO_PEDIDO_NEW);
									    ELSE
									    	SP_ACOMER_ACT_PEDIDO_CLI(0,V_CEDULA_CLIENTE,V_NOMBRE_COMPLETO,V_FORMA_PAGO,CV_EMPRESA,V_DOCUMENTO_PEDIDO_NEW);
									    END IF;

									    -- SE GENERA LA FACTURA 
									    SP_ACOMER_FACTURACION_CAB_DET('PD','169',CV_EMPRESA,V_DOCUMENTO_PEDIDO_NEW,V_CEDULA_CLIENTE,V_CODIGO_MESA,V_FACNRO_CAB_DET);

									    -- SE LIVERA LA MESA 
										SP_ACOMER_FACTURA_MESA_FIN(V_CODIGO_MESA, 1);
									END;
								END;
							ELSE
								-- INSERTA LOS DATOS DE LA FACTURACION 
							    INSERT INTO TT_FACTURA_DOCUMENTOS
							    	(NUMERO_DOC, CODIGO_EMP)
							    VALUES (CV_CODIGO_PED, CV_EMPRESA);						

								-- SE ACTUALIZA LA INFORMACION DEL CLIENTE
							    IF(V_PRECIO_CLIENTE <> '01') THEN
							    	SP_ACOMER_ACT_PEDIDO_CLI(1,V_CEDULA_CLIENTE,V_NOMBRE_COMPLETO,V_FORMA_PAGO,CV_EMPRESA,CV_CODIGO_PED);
							    ELSE
							    	SP_ACOMER_ACT_PEDIDO_CLI(0,V_CEDULA_CLIENTE,V_NOMBRE_COMPLETO,V_FORMA_PAGO,CV_EMPRESA,CV_CODIGO_PED);
							    END IF;

							    -- SE GENERA LA FACTURA 
							    SP_ACOMER_FACTURACION_CAB_DET('PD','169',CV_EMPRESA,CV_CODIGO_PED,V_CEDULA_CLIENTE,V_CODIGO_MESA,V_FACNRO_CAB_DET);
								    
								-- SE LIVERA LA MESA 
								SP_ACOMER_FACTURA_MESA_FIN(V_CODIGO_MESA, 1);
							END IF;


					        FETCH CUR_PEDIDOS_PUESTO INTO CV_CODIGO_PED, CV_EMPRESA;

					    END LOOP;
					    CLOSE CUR_PEDIDOS_PUESTO;
					END;								
				END;
				
			END;
		END IF;

		-- ==========================
		-- COPIA DE LAS FACTURAS PARA NO REPETIR LAS YA REVERSADAS
		INSERT INTO TT_CAB_FACTURA_GRAL
		SELECT DISTINCT *
		FROM CAB_FACTURA_GRAL
		WHERE FACEMPCGRAL IN (SELECT CODIGO_EMP FROM TT_FACTURA_DOCUMENTOS)
		    AND FACNUMDOCGRAL IN (SELECT NUMERO_DOC FROM TT_FACTURA_DOCUMENTOS);

		-- ==========================
		-- CONSULTA EL NUMERO DE FACTURA GENERAL SIGUIENTE
		SELECT NVL(MAX(FACNROGRAL),0) + 1
		INTO V_NUM_FACGRAL
		FROM CAB_FACTURA_GRAL;

		-- ==========================
		-- INSERTO EN LA TABLA LOS VALORES QUE PERTENECEN A LA FACTURA GENERAL
		INSERT INTO CAB_FACTURA_GRAL(
		    FACNROGRAL, FACEMPCGRAL, 
		    FACNRO, FACNUMDOCGRAL,
		    FACFECHA, FACHORA)
		SELECT V_NUM_FACGRAL, A.CODIGO_EMP,
		    B.FACNRO, A.NUMERO_DOC,
		    TO_CHAR(SYSDATE, 'DD/MM/YYYY'),
		    TO_CHAR(SYSDATE, 'HH24:MI:SS')
		FROM TT_FACTURA_DOCUMENTOS A
		INNER JOIN VEN0008 B 
		    ON B.FACNUMDOC IN (A.NUMERO_DOC)
		    AND B.FACEMPC IN (A.CODIGO_EMP)
			AND B.FACNRO IN (V_FACNRO_CAB_DET);

		-- ==========================
		-- CABECERA DE LA FACTURA
		OPEN OUT_CURSOR_FACTURA FOR
			SELECT DISTINCT FACNROGRAL NUMERO_FAC,
			    FACFECHA FECHA,
			    FACHORA HORA
			FROM CAB_FACTURA_GRAL
			WHERE FACEMPCGRAL IN (SELECT CODIGO_EMP FROM TT_FACTURA_DOCUMENTOS)
			    AND FACNUMDOCGRAL IN (SELECT NUMERO_DOC FROM TT_FACTURA_DOCUMENTOS);

		-- ==========================
		-- DETALLE DE LA FACTURA 
		OPEN OUR_CURSOR_FACTURA_C FOR
			SELECT C.PRODES, A.PEDUNI,
			    A.PEDVAL * A.PEDUNI PEDVALTUN
			FROM VEN0004 A
			INNER JOIN VEN0104 B
			    ON A.PEDNRO = B.PEDNRO
			    AND B.PEDEMPC IN (SELECT CODIGO_EMP FROM TT_FACTURA_DOCUMENTOS)
			    AND B.PEDNUMDOC IN (SELECT NUMERO_DOC FROM TT_FACTURA_DOCUMENTOS)
			INNER JOIN VEN0001 C 
			    ON A.PEDPROCOD = C.PROCOD;

		-- ==========================
		-- TOTAL A PAGAR 
		SELECT SUM(PEDVALTUN)
		INTO OUT_TOTAL_PAGAR
		FROM VEN0004 A
		INNER JOIN VEN0104 B
		    ON A.PEDNRO = B.PEDNRO
		    AND B.PEDEMPC IN (SELECT CODIGO_EMP FROM TT_FACTURA_DOCUMENTOS)
		    AND B.PEDNUMDOC IN (SELECT NUMERO_DOC FROM TT_FACTURA_DOCUMENTOS);
	  
	  COMMIT;
	END SP_ACOMER_FACTURACION;

-- =============================================
-- ACTUALIZACION DE LOS DATOS DEL PEDIDO
	PROCEDURE SP_ACOMER_FACTURACION_ACT
	(
		IN_TIPO_PRECIO IN GEN0024.LIPCOD%TYPE, -- PRECIO QUE SE LE DEBE AJUSTAR AL PEDUDO
		IN_CODIGO_MESA IN VEN0104.MESCOD%TYPE, -- CODIGO DE LA MESA DEL PEDIDO 
		IN_PUESTOS_ARRAY IN TYPE_PEDIDOS_ARRAY -- PUESTOS QUE SE VAN A FACTURAR
	)
	AS
		V_PEDIDO_RESTAURANTE1 INV00018.MESNUMREQ%TYPE;
		V_PEDIDO_RESTAURANTE2 INV00018.MESNUMREQ2%TYPE;
		V_PEDIDO_RESTAURANTE3 INV00018.MESNUMREQ3%TYPE;
		V_PEDIDO_RESTAURANTE4 INV00018.MESNUMREQ4%TYPE;

		V_TAMANO NUMBER;
	BEGIN
		-- ===================================
		-- IDENTIFICAR LOS PEDIDOS QUE HAY EN LA MESA 
		SELECT NVL(MESNUMREQ,''), 
			NVL(MESNUMREQ2,''), 
			NVL(MESNUMREQ3,''),
			NVL(MESNUMREQ4,'')
		INTO V_PEDIDO_RESTAURANTE1, V_PEDIDO_RESTAURANTE2,
			V_PEDIDO_RESTAURANTE3, V_PEDIDO_RESTAURANTE4
		FROM INV00018
		WHERE MESCOD = IN_CODIGO_MESA;

		-- SABER SI ES UNA SOLA FACTURA
		BEGIN
			V_TAMANO := TO_NUMBER(IN_PUESTOS_ARRAY(1));
		EXCEPTION
			WHEN OTHERS THEN 
				V_TAMANO := 0;
		END;
	    
		-- SI EL ARRAY ES VACIO SE HACE UNA SOLA FACTURA 
		-- SI NO SE HACE LA FACTURA DE LOS PEDIDOS DETERMINADOS 
		IF(V_TAMANO <> 0) THEN
			-- ===================================
			-- MULTIPLE FACTURA
			BEGIN
				-- ===================================
				-- LEER CADA PEDIDO HECHO OR LA MESA Y ACTULIZAR SU PRECIO A USAR
				DECLARE
					CV_PLATO VEN0004.PEDPROCOD%TYPE; -- CODIGO DE LOS PLATOS PEDIDOS EN LA MESA 
					CV_CANTIDAD VEN0004.PEDUNI%TYPE;  -- CANTIDAD PEDIDO DEL PLATO
					CV_COD_EMPRESA VEN0004.PEDEMPC%TYPE; -- CODIGO DE LA EMPRESA A LA QUE PERTENECE EL PLATO
					CV_NUM_PEDIDO VEN0004.PEDNRO%TYPE;   -- NUMERO DEL PEDIDO DE LA MESA EN RESTAURANTE
					-- CURSOR PARA CONSULTAR LOS PEDIDOS HECHOS EN LA MESA
					CURSOR C_PRECIO_PED (IN_CUR_PUESTO IN CHAR) IS 
						SELECT DISTINCT PEDPROCOD, PEDUNI, A.PEDEMPC,
							A.PEDNRO
				        FROM VEN0004 A	     
			            LEFT JOIN VEN0104 B
			                ON A.PEDNRO = B.PEDNRO                  
			                AND A.CCOCOD = IN_CUR_PUESTO
				        WHERE B.PEDNUMDOC = V_PEDIDO_RESTAURANTE1
			                OR B.PEDNUMDOC = V_PEDIDO_RESTAURANTE2
			                OR B.PEDNUMDOC = V_PEDIDO_RESTAURANTE3
			                OR B.PEDNUMDOC = V_PEDIDO_RESTAURANTE4;
				    V_NEW_PRECIO VEN00012.PROPRE%TYPE; -- PRECIO POR EL CUAL SE VA ACTUALIZAR
				    V_PRECIO_IVA VEN0004.PEDVALIVA%TYPE; -- PRECIO DEL PLATO CON IVA INCLUIDO 
				    V_RFPORDTO VEN0001.RFPORDTO%TYPE;
				    V_VALDESC VEN0004.peddcval%TYPE;   -- peddcval
				BEGIN
					-- ===================================
					-- RECORRE EL ARRAY DE LOS PUESTOS CON PEDIDOS QUE SE VAN ACTUALIZAR PRECIOS 
					FOR I IN IN_PUESTOS_ARRAY.FIRST..IN_PUESTOS_ARRAY.LAST
					LOOP
						-- ===================================
						-- ABRE EL CURSOR 
						OPEN C_PRECIO_PED(IN_PUESTOS_ARRAY(I));
						-- CICLO PARA LEER LOS DATOS DEVUELTOS EN EL CURSOR
						LOOP
							--RAISE_APPLICATION_ERROR('PUESTO: '||IN_PUESTOS_ARRAY(I),SQLERRM);
							-- OBTENER LOS DATOS FILA POR FILA 
							FETCH C_PRECIO_PED INTO CV_PLATO, CV_CANTIDAD, CV_COD_EMPRESA, CV_NUM_PEDIDO;
							-- SALE DEL CICLO CUANDO NO ENCUENTRE NINGUN DATO  EN EL CURSOR
							EXIT WHEN C_PRECIO_PED%NOTFOUND;
							--CONSULTA EL PRECIO DEL PRODUCTO PARA EL CLIENTE REGISTRADO
							SELECT PROPRE 
							INTO V_NEW_PRECIO
							FROM VEN00012
							WHERE LIPCOD = IN_TIPO_PRECIO
							    AND PROCOD = CV_PLATO;
							--END LOOP;
							-- CALCULA EL IVA DEL PLATO Y SE LO SUMA 
							 SELECT ((CNT0014.DEDPOR / 100) * V_NEW_PRECIO) + V_NEW_PRECIO 
							INTO V_PRECIO_IVA
							FROM VEN0001 
							LEFT JOIN CNT0014  
							    ON VEN0001.FDEDCOD = CNT0014.DEDCOD 
							    AND VEN0001.FDEDSC = CNT0014.DEDSUBCOD
							    AND VEN0001.FDEDANO = CNT0014.DEDANO 
							WHERE VEN0001.VENEMPPAI = '169' 
							    AND VEN0001.VENEMPC = CV_COD_EMPRESA
							    AND VEN0001.PROCOD = CV_PLATO;
							--
							 --RAISE_APPLICATION_ERROR(-20001, CV_PLATO||' - '||CV_NUM_PEDIDO);
							SELECT DISTINCT RFPORDTO
						    INTO V_RFPORDTO
						    FROM VEN0001 A
						    INNER JOIN VEN0004 B
						        ON A.VENEMPPAI = B.PEDPAIC
						        AND A.VENEMPC = B.PEDEMPC
						        AND A.PROCOD = B.PEDPROCOD 
						    WHERE A.PROCOD = CV_PLATO
						        AND B.PEDNRO = CV_NUM_PEDIDO;
						    --
						    IF(V_RFPORDTO > 0) THEN
								BEGIN
									V_VALDESC := (V_NEW_PRECIO * CV_CANTIDAD * V_RFPORDTO) / 100;
								END;
							ELSE
								BEGIN
									V_RFPORDTO := 0;
									V_VALDESC := 0;
								END;
							END IF;
	                        
							UPDATE VEN0004
							SET PEDVAL = V_NEW_PRECIO,-- VALOR DEL PLATO
							    PEDVALIVA = V_PRECIO_IVA,-- VALOR DEL PLATO CON IVA
							    PEDVALTUN = V_PRECIO_IVA * CV_CANTIDAD, -- VALOR DEL PLATO CON LA CANTIDA E IVA
							    PEDPORDC = V_RFPORDTO,
			   					PEDDCVAL = V_VALDESC
			   				WHERE CCOCOD = CAST(IN_PUESTOS_ARRAY(I) AS CHAR(3))
			   					AND PEDNRO = CV_NUM_PEDIDO
			   					AND PEDPROCOD = CV_PLATO;
	                    END LOOP;
						-- CIERRA EL CURSRO
						CLOSE C_PRECIO_PED;
					END LOOP;
				END;
			END;


		ELSE
			-- ===================================
			-- UNICA FACTURA 		
			BEGIN
				-- ===================================
				-- LEER CADA PEDIDO HECHO OR LA MESA Y ACTULIZAR SU PRECIO A USAR
				DECLARE
					CV_PLATO VEN0004.PEDPROCOD%TYPE; -- CODIGO DE LOS PLATOS PEDIDOS EN LA MESA 
					CV_CANTIDAD VEN0004.PEDUNI%TYPE;  -- CANTIDAD PEDIDO DEL PLATO
					CV_COD_EMPRESA VEN0004.PEDEMPC%TYPE; -- CODIGO DE LA EMPRESA A LA QUE PERTENECE EL PLATO
					CV_NUM_PEDIDO VEN0004.PEDNRO%TYPE;   -- NUMERO DEL PEDIDO DE LA MESA EN RESTAURANTE
					-- CURSOR PARA CONSULTAR LOS PEDIDOS HECHOS EN LA MESA
					CURSOR C_PRECIO_PED IS 
						SELECT DISTINCT PEDPROCOD, PEDUNI, A.PEDEMPC,
					        A.PEDNRO
					    FROM VEN0004 A	     
					    LEFT JOIN VEN0104 B
					        ON A.PEDNRO = B.PEDNRO                  
					    WHERE B.PEDNUMDOC = V_PEDIDO_RESTAURANTE1
			                OR B.PEDNUMDOC = V_PEDIDO_RESTAURANTE2
			                OR B.PEDNUMDOC = V_PEDIDO_RESTAURANTE3
			                OR B.PEDNUMDOC = V_PEDIDO_RESTAURANTE4;
				    V_NEW_PRECIO VEN00012.PROPRE%TYPE; -- PRECIO POR EL CUAL SE VA ACTUALIZAR
				    V_PRECIO_IVA VEN0004.PEDVALIVA%TYPE; -- PRECIO DEL PLATO CON IVA INCLUIDO 
				    V_RFPORDTO VEN0001.RFPORDTO%TYPE;
				    V_VALDESC VEN0004.peddcval%TYPE;   -- peddcval
				BEGIN				
					-- ===================================
					-- ABRE EL CURSOR 
					OPEN C_PRECIO_PED;
					-- CICLO PARA LEER LOS DATOS DEVUELTOS EN EL CURSOR
					LOOP
						-- OBTENER LOS DATOS FILA POR FILA 
						FETCH C_PRECIO_PED INTO CV_PLATO, CV_CANTIDAD, CV_COD_EMPRESA, CV_NUM_PEDIDO;
						-- SALE DEL CICLO CUANDO NO ENCUENTRE NINGUN DATO  EN EL CURSOR
						EXIT WHEN C_PRECIO_PED%NOTFOUND;
						--CONSULTA EL PRECIO DEL PRODUCTO PARA EL CLIENTE REGISTRADO
						SELECT PROPRE 
						INTO V_NEW_PRECIO
						FROM VEN00012
						WHERE LIPCOD = IN_TIPO_PRECIO
						    AND PROCOD = CV_PLATO;				
						-- CALCULA EL IVA DEL PLATO Y SE LO SUMA 
						 SELECT ((CNT0014.DEDPOR / 100) * V_NEW_PRECIO) + V_NEW_PRECIO 
						INTO V_PRECIO_IVA
						FROM VEN0001 
						LEFT JOIN CNT0014  
						    ON VEN0001.FDEDCOD = CNT0014.DEDCOD 
						    AND VEN0001.FDEDSC = CNT0014.DEDSUBCOD
						    AND VEN0001.FDEDANO = CNT0014.DEDANO 
						WHERE VEN0001.VENEMPPAI = '169' 
						    AND VEN0001.VENEMPC = CV_COD_EMPRESA
						    AND VEN0001.PROCOD = CV_PLATO;
						--
						SELECT RFPORDTO
					    INTO V_RFPORDTO
					    FROM VEN0001 A
					    INNER JOIN VEN0004 B
					        ON A.VENEMPPAI = B.PEDPAIC
					        AND A.VENEMPC = B.PEDEMPC
					        AND A.PROCOD = B.PEDPROCOD 
					    WHERE A.PROCOD = CV_PLATO
					        AND B.PEDNRO = CV_NUM_PEDIDO;
					    --
					    IF(V_RFPORDTO > 0) THEN
							BEGIN
								V_VALDESC := (V_NEW_PRECIO * CV_CANTIDAD * V_RFPORDTO) / 100;
							END;
						ELSE
							BEGIN
								V_RFPORDTO := 0;
								V_VALDESC := 0;
							END;
						END IF;

						UPDATE VEN0004
						SET PEDVAL = V_NEW_PRECIO,-- VALOR DEL PLATO
						    PEDVALIVA = V_PRECIO_IVA,-- VALOR DEL PLATO CON IVA
						    PEDVALTUN = V_PRECIO_IVA * CV_CANTIDAD, -- VALOR DEL PLATO CON LA CANTIDA E IVA
						    PEDPORDC = V_RFPORDTO,
		   					PEDDCVAL = V_VALDESC
		   				WHERE PEDNRO = CV_NUM_PEDIDO
		   					AND PEDPROCOD = CV_PLATO;
		   			END LOOP;
					-- CIERRA EL CURSRO
					CLOSE C_PRECIO_PED;
					
				END;
			END;
		END IF;		
	END SP_ACOMER_FACTURACION_ACT;

-- =============================================
-- ACTUALIZA LOS DATOS DEL CLIENTE EN EL PEDIDO
	PROCEDURE SP_ACOMER_ACT_PEDIDO_CLI
	(
		IN_REGISTRADO_BD NUMBER, -- SABER SI YA ESTA REGISTRADO O NO
		IN_CEDULA_CLIENTE VEN0104.PCLICOD%TYPE, -- CEDULA DEL CLIENTE
		IN_NOMBRE_CLINETE VEN0104.PCLINOM%TYPE, -- NOMBRE DEL CLIENTE
		IN_FORMA_PAGO VEN0104.PFPGCOD%TYPE,      -- FORMA DE PAGO
		IN_CODIGO_EMPRESA GEN0006.EMPCOD%TYPE,	-- CODIGO DE LA EMPRESA
		IN_NUMERO_DOCUMENTO CNT00071.MOVDOCNRO%TYPE  -- CODIGO DEL PEDIDO 
	)
	AS
		V_DIR_CLIENTE VEN0003.DIRCOD%TYPE;  -- INFORMACION PARA CLIENTES QUE ESTAN REGISTRADOS
		V_DIRECCION VEN0003.DIRCLIDIR%TYPE; -- INFORMACION PARA CLIENTES QUE ESTAN REGISTRADOS
		V_NUMERO_PEDIDO VEN0004.PEDNRO%TYPE;-- NUMERO DE PEDIDO  
	BEGIN
		-- ==================
		-- CODIGO DEL PEDIDO EN DETALLE
		SELECT PEDNRO 
		INTO V_NUMERO_PEDIDO
		FROM VEN0104
		WHERE PEDEMPC = IN_CODIGO_EMPRESA
			AND PEDNUMDOC = IN_NUMERO_DOCUMENTO;

		-- 1: ESTA REGISTRADO EN LA BASE DE DATOS
		-- 0: NO ESTA REGISTRADO EN LA BASE DE DATOS

		-- ===================
		-- SI EL CLIENTE ESTA REGISTRADO EN BD
		IF(IN_REGISTRADO_BD = 1) THEN
			BEGIN
				-- CONSULTAMOS LA INFROMACION ADICIONAL 
				SELECT DIRCOD, DIRCLIDIR 
				INTO V_DIR_CLIENTE,V_DIRECCION 
				FROM  VEN0003 
				WHERE CLICOD = IN_CEDULA_CLIENTE 
					AND SUCTERCOD = '01' 
					AND ROWNUM <= 1;

				-- SE ACTUALIZAN LOS DATOS DEL PEDIDO
				UPDATE VEN0104
				SET PCLICOD = IN_CEDULA_CLIENTE, 
					PCLINOM = IN_NOMBRE_CLINETE, 
					PSUCCLI = '01', 
					PFPGCOD = IN_FORMA_PAGO,
					PCLICUP = 0, 
					PDIRCOD = V_DIR_CLIENTE, 
					PDIRNOM = V_DIRECCION
				WHERE PEDEMPC = IN_CODIGO_EMPRESA
					AND PEDNUMDOC = IN_NUMERO_DOCUMENTO;

				-- SE ACTUALIZA EL ESTADO DEL PEDIDO A FACTURADO
				UPDATE VEN0004
				SET PEDSAL = 'F'
				WHERE PEDNRO = V_NUMERO_PEDIDO;

			END;
		ELSE
			BEGIN
				-- SE ACTUALIZAN LOS DATOS DEL PEDIDO
				UPDATE VEN0104
				SET PCLICOD = IN_CEDULA_CLIENTE, 
					PCLINOM = IN_NOMBRE_CLINETE, 
					PSUCCLI = '01', 
					PFPGCOD = IN_FORMA_PAGO,
					PCLICUP = 0 				
				WHERE PEDEMPC = IN_CODIGO_EMPRESA
					AND PEDNUMDOC = IN_NUMERO_DOCUMENTO;

				-- SE ATUALIZA EL ESTADO DEL PEDIDO A FACTURADO
				UPDATE VEN0004
				SET PEDSAL = 'F'
				WHERE PEDNRO = V_NUMERO_PEDIDO;
			END;
		END IF;
	END SP_ACOMER_ACT_PEDIDO_CLI;

-- =============================================
-- INSERCION DE LA CABECERA Y EL DETALLE DE LA FACTURA
	PROCEDURE SP_ACOMER_FACTURACION_CAB_DET
	(
		IN_DOC_PEDIDO IN GEN0012.DOCCOD%TYPE,   		-- DOCUMENTO PEDIDO PD
		IN_CODIGO_PAIS IN GEN0006.EMPPAIC%TYPE, 		-- CODIGO DEL PAIS
		IN_CODIGO_EMPRESA IN GEN0006.EMPCOD%TYPE, 		-- CODIGO DE LA EMPRESA
		IN_NUMERO_DOCUMENTO IN CNT00071.MOVDOCNRO%TYPE, -- CODIGO DEL PEDIDO 
		IN_CODIGO_USUARIO IN SEG0001.USUID%TYPE,		-- CODIGO DEL USUARIO
		IN_CODIGO_MESA IN INV00018.MESCOD%TYPE,			-- CODIGO DE LA MESA
		OUT_NUMERO_FACTURA OUT VEN0008.FACNRO%TYPE 		-- NUMERO DE FACTURA QUE SE LE ASUGNA A LOS PEDIDOS 
	)
	AS
		V_NUMERO_FACTURA VEN0008.FACNRO%TYPE;
		V_DOCUMENT_FAC GEN0012.DOCCOD%TYPE;  
	BEGIN
		V_DOCUMENT_FAC := 'FV';  
		----------------------------------------------------
		-- NUMERO DE FACTURA SIGUIENTE SI NO EXISTE LE ASIGNA LA PRIMERA YA QUE NO HAY REGISTRO
		BEGIN      
			SELECT NVL(MAX(FACNRO),0) + 1 
			INTO V_NUMERO_FACTURA 
			FROM  VEN0008  
			WHERE FACPAIC = IN_CODIGO_PAIS 
			AND FACEMPC = IN_CODIGO_EMPRESA;
		EXCEPTION 
			WHEN NO_DATA_FOUND THEN
				V_NUMERO_FACTURA := 1;
		END;

		-- ===================================
		-- SE ASIGNA EL NUMERO ASIGNADO A LA VARIABLE DE SALDA 
		OUT_NUMERO_FACTURA := V_NUMERO_FACTURA;
		
		-- ===================================
		-- INSERTAR EN LA CABECERA DE LA FACTURA
		INSERT INTO VEN0008(
			FACPAIC, FACEMPC,
			FACCODDOC,FACNRO,
			FACNUMDOC,FACFECH,
			FACMC,CPRPAIC,
			CPREMPC,FPDOCC,
			FPDOCN,FCPRNRO,
			DIRCOD,FORPAGCOD,
			FACVENCOD,FACBODC,
			FACTIPMOV,FACUSUARIO,
			FACTOTFAC1,FACOTM,      
			TOTALFACTURA,EMPPAIC,
			EMPCOD,CLICOD,
			SUCTERCOD,FACPAIS,
			FACEMPRESA,MESCOD)
		SELECT IN_CODIGO_PAIS ,IN_CODIGO_EMPRESA, 
			V_DOCUMENT_FAC, V_NUMERO_FACTURA, 
			A.PEDNUMDOC, A.PEDFECH,
			'FACTURA',IN_CODIGO_PAIS, 
			IN_CODIGO_EMPRESA,A.PEDCODDOC,
			A.PEDNUMDOC, A.PEDNRO, 
			A.PDIRCOD, A.PFPGCOD, 
			A.PEDVENCOD, A.PEDBODCOD,
			'P', IN_CODIGO_USUARIO, 
			SUM(B.PEDVALTUN),'N', 
			SUM(B.PEDVALTUN),IN_CODIGO_PAIS, 
			IN_CODIGO_EMPRESA, A.PCLICOD,
			A.PSUCCLI,IN_CODIGO_PAIS,
			IN_CODIGO_EMPRESA,IN_CODIGO_MESA
	    FROM VEN0104 A 
	    LEFT JOIN VEN0004 B 
			ON A.PEDPAIC=B.PEDPAIC 
			AND A.PEDEMPC=B.PEDEMPC 
			AND A.PEDCODDOC=B.PEDCODDOC 
			AND A.PEDNRO=B.PEDNRO
	    WHERE A.PEDPAIC=IN_CODIGO_PAIS 
			AND A.PEDEMPC=IN_CODIGO_EMPRESA 
			AND  A.PEDCODDOC=IN_DOC_PEDIDO  
			AND A.PEDNUMDOC=IN_NUMERO_DOCUMENTO		
	    GROUP BY A.PEDNUMDOC,A.PEDFECH,
			A.PEDCODDOC,A.PEDNRO, 
			A.PDIRCOD, A.PFPGCOD, 
			A.PEDVENCOD, A.PEDBODCOD, 
			A.PCLICOD,A.PSUCCLI;

		-- ===================================
		-- INSERTAR DETALLET  DE LA FACTURA
		INSERT INTO VEN00081(
			FACPAIC,FACEMPC,
			FACCODDOC,FACNRO,
			FACLIN,FPROPC,
			FPROEC,FACPROCOD,
			BODCODLIN,FUNICPR,
			FACUNI,FACUNID,
			FACVALUNI,FACDIP,
			FACVALIVA,FACVALTUN,
			FACDCP,FACSUCDET,
			FACFRANUM,FACCLICOD,
			FACFECDED,FACVENDET,
			FACNETO,FACCCO,
			FACALIAS,
			FACTIPOIVA,
			FACDETPAI,FACDETEMP)
		SELECT IN_CODIGO_PAIS FACPAIC, IN_CODIGO_EMPRESA FACEMPC,
			V_DOCUMENT_FAC FACCODDOC, V_NUMERO_FACTURA FACNRO, 
			A.PEDLIN FACLIN, IN_CODIGO_PAIS FPROPC, 
			IN_CODIGO_EMPRESA FPROEC,A.PEDPROCOD FACPROCOD,
			A.PEDBODL BODCODLIN,A.PEDFACC FUNICPR,
			A.PEDFACC FACUNI,A.PEDFACC FACUNID,
			A.PEDVAL FACVALUNI,PEDPORIVA FACDIP,
			A.PEDVALIVA FACVALIVA,A.PEDVALTUN FACVALTUN,
			A.PEDPORDC FACDCP,A.PEDSUCDET FACSUCDET,
			'5024' FACFRANUM,B.PCLICOD FACCLICOD,
			B.PEDFECH FACFECDED,PEDVENCOD FACVENDET,
			A.PEDVALIVA + A.PEDVALTUN FACNETO,A.CCOCOD FACCCO, 
			A.PEDALIAS FACALIAS, 
			CASE WHEN PEDVALIVA > 0 
				THEN 'Gravado' 
				ELSE 'SinIVA' 
			END FACTIPOIVA,  
			IN_CODIGO_PAIS FACDETPAI, IN_CODIGO_EMPRESA FACDETEMP
		FROM VEN0004 A
		LEFT JOIN VEN0104 B 
			ON A.PEDPAIC = B.PEDPAIC 
			AND A.PEDEMPC = B.PEDEMPC 
			AND A.PEDCODDOC = B.PEDCODDOC 
			AND A.PEDNRO = B.PEDNRO		
		WHERE A.PEDCODDOC = IN_DOC_PEDIDO 
			AND B.PEDNUMDOC = IN_NUMERO_DOCUMENTO;
	END SP_ACOMER_FACTURACION_CAB_DET;

-- =============================================
-- LIBERAR LA MESA DESPUES DE UNA FACTURACION FINAL
	PROCEDURE SP_ACOMER_FACTURA_MESA_FIN
	(
		IN_CODIGO_MESA IN VEN0104.MESCOD%TYPE, 	-- CODIGO DE LA MESA DEL PEDIDO 	
		IN_PUESTOS IN NUMBER					-- SABER SI LA FACTURACION ES POR PUESTOS
	)
	AS
		V_CONTADOR NUMBER; -- CANTIDAD DE PUESTOS QUE FALTA POR FACTURAR
		V_CODIGO_PEDIDO TYPE_PEDIDOS_ARRAY; -- CODIGO DE LOS PEDIDOS QUE HAY EN MESA

	BEGIN
		-- 1: FACTURACION POR PUESTOS
		-- 0: FACTURACION COMPLETA POR MESA

		IF(IN_PUESTOS = 0) THEN
			BEGIN
				-- SE LIVERA LA MESA COLOCANDOLA DISPONIBLE PARA CREAR UN NUEVO PEDIDO 
				UPDATE INV00018
				SET MESESTADO = 'Activo',
					MESDOCREQ = '',
					MESNUMREQ = '',
					MESNUMREQ2 = '',
					MESNUMREQ3 = '',
					MESNUMREQ4 = '',
					MESUSUREQ = '',
					MESHORAPED = ''
				WHERE MESCOD = IN_CODIGO_MESA;
			END;
		ELSE
			BEGIN
				-- CODIGO DE LOS PEDIDOS EN LA MESA
				SELECT MESNUMREQ, MESNUMREQ2,
					MESNUMREQ3, MESNUMREQ4
				INTO V_CODIGO_PEDIDO(0), V_CODIGO_PEDIDO(1),
					V_CODIGO_PEDIDO(3), V_CODIGO_PEDIDO(4)
				FROM INV00018
				WHERE MESCOD = IN_CODIGO_MESA;

				-- CANTIDAD DE PUESTOS POR FACTURAR
				SELECT COUNT(*)
				INTO V_CONTADOR
			    FROM VEN0004 A
			    INNER JOIN VEN0104 B
			        ON A.PEDNRO = B.PEDNRO
			        AND B.PEDNUMDOC IN (V_CODIGO_PEDIDO(0), V_CODIGO_PEDIDO(1),	V_CODIGO_PEDIDO(3), V_CODIGO_PEDIDO(4))
			    WHERE PEDSAL NOT IN ('F');		    

			    -- SI EL CONTADOR ES 0 SE LIBERA LA MESA
			    IF(V_CONTADOR = 0) THEN 
			    	-- SE LIVERA LA MESA COLOCANDOLA DISPONIBLE PARA CREAR UN NUEVO PEDIDO 
					UPDATE INV00018
					SET MESESTADO = 'Activo',
						MESDOCREQ = '',
						MESNUMREQ = '',
						MESNUMREQ2 = '',
						MESNUMREQ3 = '',
						MESNUMREQ4 = '',
						MESUSUREQ = '',
						MESHORAPED = ''
					WHERE MESCOD = IN_CODIGO_MESA;
					SP_ACOMER_LIBERAR_MESA_UNIDA(IN_CODIGO_MESA);
					--RAISE_APPLICATION_ERROR(-20001,'Se libera:'||V_CONTADOR);           
			    END IF;
			    
			END;
		END IF;
		
	END SP_ACOMER_FACTURA_MESA_FIN;

-- =============================================
-- ESTADO DE UNA MESA ESPECIFICADA
	PROCEDURE SP_ACOMER_ESTADO_MESA_FAC
	(
		IN_CODIGO_MESA IN INV00018.MESCOD%TYPE,  -- CODIGO DE LA MESA DEL PEDIDO 	
		OUT_ESTADO OUT NUMBER					 -- ESTADO DE LA MESA 
	)
	AS
	BEGIN	
		SELECT 
			CASE MESESTADO 
				WHEN 'Activo' THEN 1
				ELSE 0
			END ESTADO
		INTO OUT_ESTADO
		FROM INV00018
		WHERE MESCOD = IN_CODIGO_MESA;
	END SP_ACOMER_ESTADO_MESA_FAC;

-- =============================================
-- FACTURA QUE SE LE ENTREGA AL CLIENTE
	PROCEDURE SP_ACOMER_FACTURA_CLIENTE
	(
		IN_FECHA_FACTURA IN CAB_FACTURA_GRAL.FACFECHA%TYPE,	-- FECHA QUE SE FACTURA
		IN_HORA_FACTURA IN CAB_FACTURA_GRAL.FACHORA%TYPE,	-- HORA EN LA QUE SE FACTURA
		IN_FACTURA_GENERAL IN TYPE_PEDIDOS_ARRAY,	        -- NUMERO DE LA FACTURA GENERAL
		IN_CODIGO_MESERO IN INV00018.MESUSUREQ%TYPE,		-- CODIGO DEL MESERO
		IN_PORCENTAJE_PROPINA IN NUMBER,					-- PORCENTAJE DE LA PROPINA VOLUNTARIA 
		OUT_FACTURA_CLIENTE OUT SYS_REFCURSOR				-- DATOS DE LA FACTURA 
	)
	AS
		V_NUMERO_FACTURA TAB_FACTURA_CLIENTE.FACNROCLI%TYPE;
		V_CONSEC_FACTURA TAB_FACTURA_CLIENTE.FACCONS%TYPE;
		V_CODIGO_CLIENTE VEN0104.PCLICOD%TYPE;
		V_NOMBRE_CLIENTE VEN0104.PCLINOM%TYPE;
		V_VALOR_IVA NUMBER := 0;
		V_VALOR_SUBTOTAL NUMBER := 0;
		V_VALOR_TOTAL NUMBER := 0;
		V_VALOR_PROPINA NUMBER;
	BEGIN
		-- ===========================
		-- SE CALCULA EL NUMERO DE LA FACTURA 
		BEGIN
			SELECT NVL(MAX(FACNROCLI),0) + 1
			INTO V_NUMERO_FACTURA
			FROM TAB_FACTURA_CLIENTE;
		-- SI NO ENCUENTRA DATOS DEVUELVE EL PRIMER NUMERO DE LA FACTURA 
		EXCEPTION 
			WHEN NO_DATA_FOUND THEN 
				V_NUMERO_FACTURA := 1;
		END;

		-- ==========================
		-- CONSULTA EL NOMBRE Y EL CODIGO DEL CLIENTE
		BEGIN
			SELECT DISTINCT B.PCLICOD, B.PCLINOM
			INTO V_CODIGO_CLIENTE, V_NOMBRE_CLIENTE
			FROM CAB_FACTURA_GRAL A
			INNER JOIN VEN0104 B
			  ON A.FACNUMDOCGRAL = B.PEDNUMDOC
			WHERE A.FACNROGRAL = CAST(IN_FACTURA_GENERAL(1) AS NUMBER(10));
		END;	

		-- ==========================
		-- SE RECORRE EL ARRAY DE LOS CODIGOS DE LAS FACTURAS GENERALES
		FOR I IN IN_FACTURA_GENERAL.FIRST..IN_FACTURA_GENERAL.LAST
		LOOP
			-- SE CONSULTA  EL IVA EL SUBTOTAL Y EL TOTAL DE TODA LA FACTURA DEL CLIENTE
			SELECT SUM(IVA) + V_VALOR_IVA, 
				SUM(SUBTOTAL) + V_VALOR_SUBTOTAL, 
				SUM(TOTAL) +V_VALOR_TOTAL
			INTO V_VALOR_IVA, 
				V_VALOR_SUBTOTAL, 
				V_VALOR_TOTAL
			FROM CAB_FACTURA_GRAL
			WHERE FACNROGRAL = CAST(IN_FACTURA_GENERAL(I) AS NUMBER(10));
		END LOOP;	

		-- VALOR DE LA PROPINA ACORDE A SU PORCENTAJE DADO
		V_VALOR_PROPINA := V_VALOR_SUBTOTAL * (IN_PORCENTAJE_PROPINA/100);
		-- RECALCULA CON LA PROPINA EL VALOR TOTAL
		V_VALOR_TOTAL := V_VALOR_TOTAL + V_VALOR_PROPINA;

		-- ========================
		-- SE INSERTA EN LA TABLA FACTURA CLIENTE
		FOR I IN IN_FACTURA_GENERAL.FIRST..IN_FACTURA_GENERAL.LAST
		LOOP
			-- ===========================
			-- SE CALCULA EL NUMERO CONSECUTIVO DE LA FACTURA		
			SELECT NVL(MAX(FACCONS),0) + 1
			INTO V_CONSEC_FACTURA
			FROM TAB_FACTURA_CLIENTE;			
			
			-- 
			INSERT INTO TAB_FACTURA_CLIENTE(
				FACNROCLI, FACNROGRAL, FACCONS, 
				FACFECH, FACHORA, FACCEDCLI, 
				FACNOMCLI, FACCODMES, FACIVA, 
				FACSUBTOTAL, FACTOTAL,
				FACPROPINA, FACVALPROPINA)
			VALUES(
				V_NUMERO_FACTURA,  CAST(IN_FACTURA_GENERAL(I) AS NUMBER(10)), V_CONSEC_FACTURA,
				IN_FECHA_FACTURA, IN_HORA_FACTURA, V_CODIGO_CLIENTE,
				V_NOMBRE_CLIENTE, IN_CODIGO_MESERO, V_VALOR_IVA,
				V_VALOR_SUBTOTAL, V_VALOR_TOTAL,
				IN_PORCENTAJE_PROPINA, V_VALOR_PROPINA);

			COMMIT;
		END LOOP;
			


		-- ========================
		-- CURSOR QUE RETORNA LOS DATOS DE LA FACTURA DEL CLIENTE
		OPEN OUT_FACTURA_CLIENTE FOR		
			SELECT LPAD(V_NUMERO_FACTURA,6,0) NUMERO_FAC,
			    IN_FECHA_FACTURA FECHA,
			    V_VALOR_SUBTOTAL SUBTOTAL,
			    V_VALOR_IVA IVA,
			    V_VALOR_TOTAL TOTAL,
			    V_VALOR_PROPINA PROPINA
			FROM DUAL;

		/*RAISE_APPLICATION_ERROR(-20001, 'FAC NRO: '||V_NUMERO_FACTURA||' ||| '||'FAC GRAL: '||IN_FACTURA_GENERAL(0)||' ||| '||
										'CONSEC: ' ||V_CONSEC_FACTURA||' ||| '||'FECHA: '   ||IN_FECHA_FACTURA  ||' ||| '||
										'HORA: '   ||IN_HORA_FACTURA ||' ||| '||'CEDULA: '  ||V_CODIGO_CLIENTE  ||' ||| '||
										'NOMBRE: ' ||V_NOMBRE_CLIENTE||' ||| '||'MESERO: '  ||IN_CODIGO_MESERO  ||' ||| '||
										'IVA: '    ||V_VALOR_IVA     ||' ||| '||'SUBTOTAL: '||V_VALOR_SUBTOTAL  ||' ||| '||
										'TOTAL: '  ||V_VALOR_TOTAL);*/

	END SP_ACOMER_FACTURA_CLIENTE;

-- =============================================
-- RESPALDO DE LOS DATOS DESPUES DE FACTURAR PARA REVERSAR LO HECHO
	PROCEDURE SP_ACOMER_FACTURA_RESPALDO
	(
		IN_CODIGO_MESA IN INV00018.MESCOD%TYPE, -- CODIGO DE LA MESA QUE SE SACARA RESPALDO DEL PEDIDO
		OUT_CODIGO_REVER OUT NUMBER				-- NUMERO DE REVER QUE SE LE ASIGNA
	)
	AS
		V_MESA_PRINCIPAL UNIONMESA.MESCOD%TYPE; -- IDENTIFICAR SI ES UNA MESA UNIDA Y DE SERLO CUAL ES LA PRINCIPAL
		V_NUMERO_REVER NUMBER;					-- NUMERO DE REVER QUE SE LE ASIGNA A LA OPERACION HECHA EN CASO DE NECESITAR LOS DATOS COMO ESTABAN
		V_NUMERO_REVER_EXT NUMBER;				-- NUMERO DE REVER QUE LA MESA TENGA SI HA DE TENERLO 
	BEGIN
		BEGIN
			--CONSULTA LA MESA PRINCIPAL SI ES UNA MESA UNIDA 
			SELECT DISTINCT MESCOD
			INTO V_MESA_PRINCIPAL
			FROM UNIONMESA
			WHERE MESCOD = IN_CODIGO_MESA
			  	OR MESCODUNI = IN_CODIGO_MESA;
		EXCEPTION 
			WHEN NO_DATA_FOUND THEN 
				V_MESA_PRINCIPAL := 0;
		END;

		BEGIN
			SELECT DISTINCT NUMEROREVER
			INTO V_NUMERO_REVER_EXT
			FROM TABCOPYINV00018 A
			WHERE A.MESCOD = IN_CODIGO_MESA;

			DELETE FROM TABCOPYINV00018
			WHERE NUMEROREVER = V_NUMERO_REVER_EXT;

			DELETE FROM TABCOPYVEN0104
			WHERE NUMEROREVER = V_NUMERO_REVER_EXT;

			DELETE FROM TABCOPYVEN0004
			WHERE NUMEROREVER = V_NUMERO_REVER_EXT;
		EXCEPTION
			WHEN NO_DATA_FOUND THEN
				V_NUMERO_REVER_EXT:= 0;
		END;

		-- SI LA  MESA PRINCIPAL ES 0 ES UNA MESA SOLA
		IF(V_MESA_PRINCIPAL = 0) THEN 
			BEGIN

				-- NUMERO QUE SE LE ASIGNA AL REVER
				SELECT NVL(MAX(NUMEROREVER),0) + 1 
				INTO V_NUMERO_REVER
				FROM TABCOPYVEN0104;

				-- COPIA DE RESPALDO EN VEN0104 PARA LA MESA X
				INSERT INTO TABCOPYVEN0104
				SELECT V_NUMERO_REVER, A.* 
				FROM VEN0104 A
				INNER JOIN INV00018 B
					ON B.MESNUMREQ  = A.PEDNUMDOC
					OR B.MESNUMREQ2 = A.PEDNUMDOC
					OR B.MESNUMREQ3 = A.PEDNUMDOC
					OR B.MESNUMREQ4 = A.PEDNUMDOC
				WHERE B.MESCOD  = IN_CODIGO_MESA;

				-- COPIA DE RESPALDO EN VEN0004 PARA LA MESA X
				INSERT INTO TABCOPYVEN0004
				SELECT V_NUMERO_REVER, A.* 
				FROM VEN0004 A
				INNER JOIN VEN0104 B
					ON A.PEDNRO = B.PEDNRO
					AND A.PEDEMPC = B.PEDEMPC
				INNER JOIN INV00018 C
					ON C.MESNUMREQ  = B.PEDNUMDOC
					OR C.MESNUMREQ2 = B.PEDNUMDOC
					OR C.MESNUMREQ3 = B.PEDNUMDOC
					OR C.MESNUMREQ4 = B.PEDNUMDOC
				WHERE C.MESCOD  = IN_CODIGO_MESA;

				-- COPIA DE RESPALDO EN INV00018
				INSERT INTO TABCOPYINV00018
				SELECT V_NUMERO_REVER, A.* 
				FROM INV00018 A
				WHERE A.MESCOD = IN_CODIGO_MESA;
			END;
		ELSE
			BEGIN
				-- NUMERO QUE SE LE ASIGNA AL REVER
				SELECT NVL(MAX(NUMEROREVER),0) + 1 
				INTO V_NUMERO_REVER
				FROM TABCOPYVEN0104;

				-- COPIA DE RESPALDO EN VEN0104 PARA LA MESA X
				INSERT INTO TABCOPYVEN0104
				SELECT V_NUMERO_REVER, A.* 
				FROM VEN0104 A
				INNER JOIN INV00018 B
					ON B.MESNUMREQ  = A.PEDNUMDOC
					OR B.MESNUMREQ2 = A.PEDNUMDOC
					OR B.MESNUMREQ3 = A.PEDNUMDOC
					OR B.MESNUMREQ4 = A.PEDNUMDOC
				WHERE B.MESCOD IN (V_MESA_PRINCIPAL)
					OR B.MESCOD IN (SELECT DISTINCT MESCODUNI FROM UNIONMESA WHERE MESCOD = V_MESA_PRINCIPAL);

				-- COPIA DE RESPALDO EN VEN0004 PARA LA MESA X
				INSERT INTO TABCOPYVEN0004
				SELECT V_NUMERO_REVER, A.* 
				FROM VEN0004 A
				INNER JOIN VEN0104 B
					ON A.PEDNRO = B.PEDNRO
					AND A.PEDEMPC = B.PEDEMPC
				INNER JOIN INV00018 C
					ON C.MESNUMREQ  = B.PEDNUMDOC
					OR C.MESNUMREQ2 = B.PEDNUMDOC
					OR C.MESNUMREQ3 = B.PEDNUMDOC
					OR C.MESNUMREQ4 = B.PEDNUMDOC
				WHERE B.MESCOD IN (V_MESA_PRINCIPAL)
					OR B.MESCOD IN (SELECT DISTINCT MESCODUNI FROM UNIONMESA WHERE MESCOD = V_MESA_PRINCIPAL);

				-- COPIA DE RESPALDO EN INV00018
				INSERT INTO TABCOPYINV00018
				SELECT V_NUMERO_REVER, A.* 
				FROM INV00018 A
				WHERE A.MESCOD IN (V_MESA_PRINCIPAL)
					OR A.MESCOD IN (SELECT DISTINCT MESCODUNI FROM UNIONMESA WHERE MESCOD = V_MESA_PRINCIPAL);

				-- COPIA DE RESPALDO EN UNIONMESA
				INSERT INTO COPYUNIONMESA
				SELECT V_NUMERO_REVER, A.*
				FROM UNIONMESA A
				WHERE A.MESCOD IN (V_MESA_PRINCIPAL);
			END;
		END IF;
		
		OUT_CODIGO_REVER := V_NUMERO_REVER;
		COMMIT;
	END SP_ACOMER_FACTURA_RESPALDO;

-- =============================================
-- REVERSAR LA FACTURACION YA HECHA 
	PROCEDURE SP_ACOMER_FACTURACION_REVER	 
	(
		IN_NUMERO_FACTURA IN TAB_FACTURA_CLIENTE.FACNROCLI%TYPE, -- NUMERO DE LA FACTURA DEL CLIENTE
		IN_NUMERO_REVER IN NUMBER								 -- NUMERO DE REVER PARA LOS DATOS ALMACENADOS ANTES DEL CAMBIO
	)
	AS	
		V_MESA_PRINCIPAL UNIONMESA.MESCOD%TYPE; -- IDENTIFICAR SI ES UNA MESA UNIDA Y DE SERLO CUAL ES LA PRINCIPAL
		-- CURSOR DE LAS MESAS QUE ESTAN INVOLUCRADAS EN EL REVER PARA INV00018
		DATA_CURSOR TABCOPYINV00018.MESCOD%TYPE;
		CURSOR CURSOR1(CUR_NROREVER NUMBER) IS
			SELECT DISTINCT MESCOD 
			FROM TABCOPYINV00018
			WHERE NUMEROREVER = CUR_NROREVER;
		-- CURSOR DE LAS MESAS QUE ESTAN INVOLUCRADAS EN EL REVER PARA VEN0104
		DATA_CURSOR2 NUMBER;
		CURSOR CURSOR2(CUR_NROREVER NUMBER, CUR_NROFACTURA NUMBER) IS
				SELECT PEDNRO 
				FROM TABCOPYVEN0104
				WHERE NUMEROREVER = CUR_NROREVER
			UNION ALL
				SELECT PEDNRO 
				FROM VEN0104 A
				WHERE A.PEDNUMDOC IN (SELECT A.FACNUMDOCGRAL
				FROM CAB_FACTURA_GRAL A
				INNER JOIN TAB_FACTURA_CLIENTE B
			  		ON A.FACNROGRAL = B.FACNROGRAL
				WHERE B.FACNROCLI = CUR_NROFACTURA);
	BEGIN
		
		-- SE GUARDA EN FACTURAS REVERSADAS
		INSERT INTO TAB_FACTURAS_REVERSADAS
		VALUES(
			IN_NUMERO_FACTURA, TO_CHAR(SYSDATE,'DD/MM/YYYY'),
			TO_CHAR(SYSDATE,'HH24:MI:SS'));

		-- ===========================================================
		-- ELIMINACION DE LOS DAOS DE INV00018 E INSERCION DE LOS ANTERIORES
		-- ABRE EL CURSOR
		OPEN CURSOR1(IN_NUMERO_REVER);
		-- SE CARGA EL PRIMER DATO DE LA FILA 
		FETCH CURSOR1 INTO DATA_CURSOR;
		--CICLO PARA RECORRER LA CONSULTA DEVUELTA
		LOOP
			-- SI NO ENCUNTRA MAS DATOS SALE DEL LOOP
			EXIT WHEN CURSOR1%NOTFOUND;
			-- SE ACTUALIZAN LOS DATOS EN INV00018 DE LA MESA X
			UPDATE INV00018
			SET MESCOD = (SELECT MESCOD FROM TABCOPYINV00018 WHERE MESCOD = DATA_CURSOR AND NUMEROREVER = IN_NUMERO_REVER),
				MESESTADO = (SELECT MESESTADO FROM TABCOPYINV00018 WHERE MESCOD = DATA_CURSOR AND NUMEROREVER = IN_NUMERO_REVER),
				MESDOCREQ = (SELECT MESDOCREQ FROM TABCOPYINV00018 WHERE MESCOD = DATA_CURSOR AND NUMEROREVER = IN_NUMERO_REVER),
				MESNUMREQ = (SELECT MESNUMREQ FROM TABCOPYINV00018 WHERE MESCOD = DATA_CURSOR AND NUMEROREVER = IN_NUMERO_REVER),
				MESNUMREQ2 = (SELECT MESNUMREQ2 FROM TABCOPYINV00018 WHERE MESCOD = DATA_CURSOR AND NUMEROREVER = IN_NUMERO_REVER), 
				MESNUMREQ3 = (SELECT MESNUMREQ3 FROM TABCOPYINV00018 WHERE MESCOD = DATA_CURSOR AND NUMEROREVER = IN_NUMERO_REVER),
				MESNUMREQ4 = (SELECT MESNUMREQ4 FROM TABCOPYINV00018 WHERE MESCOD = DATA_CURSOR AND NUMEROREVER = IN_NUMERO_REVER),
				MESUSUREQ = (SELECT MESUSUREQ FROM TABCOPYINV00018 WHERE MESCOD = DATA_CURSOR AND NUMEROREVER = IN_NUMERO_REVER),
				MESHORAPED = (SELECT MESHORAPED FROM TABCOPYINV00018 WHERE MESCOD = DATA_CURSOR AND NUMEROREVER = IN_NUMERO_REVER)
			WHERE MESCOD = DATA_CURSOR;

			-- SE CARGAN LOS SIGUIENTES DATOS DE LA CONSULTA
			FETCH CURSOR1 INTO DATA_CURSOR;
		END LOOP;
		CLOSE CURSOR1;

		-- ===========================================================
		-- ELIMINACION DE LOS DAOS DE VEN0104 Y VEN0004
		-- ABRE EL CURSOR
		OPEN CURSOR2(IN_NUMERO_REVER, IN_NUMERO_FACTURA);
		-- SE CARGA EL PRIMER DATO DE LA FILA 
		FETCH CURSOR2 INTO DATA_CURSOR2;
		--CICLO PARA RECORRER LA CONSULTA DEVUELTA
		LOOP
			-- SI NO ENCUNTRA MAS DATOS SALE DEL LOOP
			EXIT WHEN CURSOR2%NOTFOUND;
			-- SE ELIMNAN LOS DATOS EN VEN0104 DE LA MESA X
			DELETE FROM VEN0104
			WHERE PEDNRO = DATA_CURSOR2;
			-- SE ELIMNAN LOS DATOS EN VEN0004 DE LA MESA X
			DELETE FROM VEN0004
			WHERE PEDNRO = DATA_CURSOR2;

			-- SE CARGAN LOS SIGUIENTES DATOS DE LA CONSULTA
			FETCH CURSOR2 INTO DATA_CURSOR2;
		END LOOP;
		CLOSE CURSOR2;
		
		-- ===========================================================
		-- INSERCION DE DATOS EN VEN0104 Y VEN0004
		INSERT INTO VEN0104
		SELECT PEDPAIC, PEDEMPC, PEDCODDOC, PEDNRO, PEDNUMDOC,
			PEDFECH, PEDFECE, COTPAIC, COTEMPC, COTDOCCOD, COTNUMDOC,
			PCLICOD, PCLINOM, PSUCCLI, PSUCCLIN, PFPGCOD, PCLICUP,
			PDIRCOD, PDIRNOM, PEDVENCOD, PEDBODCOD, PEDFAC, PEDLC,
			PEDDEDT, PEDFLE, PEDMODCOD, PEDORDCOM, PEDOTM, PEDTDEOM,
			PEDVFOM, PEDPERENC, PEDPROYEC, PEDTIEENT, PEDCONFLE, PEDAPLPRO,
			PEDFECPRO, PEDVALINS, PEDPORADM, PEDPORIMP, PEDPORUTI, PEDCONCOM1,
			PEDCONCOM2, PEDCONCOM3, PEDCONCOM4, PEDCONCOM5, PEDCONCOM6, PEDCONCOM7,
			PEDIVAFLE, PEDIFOM, PEDDPGL, PEDTIEPRO, PEDTIETRA, PEDFECOBR,
			PSUCCLIDIR, PSUCCLITE, PEDFECCONT, PEDCONOBS, PEDCODPROY, PDIRCIUD,
			USUPAIC, USUEMPC, VENUSUARIO, PEDHORA, MESCOD
		FROM TABCOPYVEN0104
		WHERE NUMEROREVER = IN_NUMERO_REVER;

		INSERT INTO VEN0004
		SELECT PEDPAIC, PEDEMPC, PEDCODDOC, PEDNRO, PEDLIN,
			PEPC, PEC, PEDPROCOD, PEDBODL, CCOCOD, SCOCOD,
			PEDUNI, PEDVAL, PEDVALCPI, PEDPORIVA, PEDVALIVA,
			PEDVALTUN, PEDDREF1, PEDDREF2, PEDPORDV, PEDDVVAL,
			PEDPORDC, PEDDCVAL, PEDPORDP, PEDDRVAL, PEDPORDCP1,
			PEDDCPVAL, PEDPORDCP2, PEDDCP2VAL, PEDSUCDET, CEUCOD,
			SCUCOD, PEDREMC, PEDFACC, PEDVALOM, PEDVIOM, PEDVLOM,
			PEDDVOM, PEDDCOM, PEDDPOM, PEDDCPOM, PEDDCP2OM, PEDOBSDET,
			PEDALIAS, PEDDLPOR, PEDDLVAL, PEDDLVOM, PEDDDPGL, PEDDDVGL,
			PEDDDVGOM, PEDCHECK, PEDSAL
		FROM TABCOPYVEN0004
		WHERE NUMEROREVER = IN_NUMERO_REVER;

		-- ===========================================================
		-- INSERCION DE DATOS EN UNION MESA
		INSERT INTO UNIONMESA
		SELECT MESCOD, MESCODUNI
		FROM COPYUNIONMESA
		WHERE NUMEROREVER = IN_NUMERO_REVER;

		UPDATE DETMESA 
		SET PUESTOS = (SELECT CASE COUNT(*) WHEN 1 THEN 6 ELSE 4 END FROM COPYUNIONMESA WHERE NUMEROREVER = IN_NUMERO_REVER)
		WHERE MESCOD = (SELECT MESCOD FROM COPYUNIONMESA WHERE NUMEROREVER = IN_NUMERO_REVER)
		    OR MESCOD = (SELECT MESCODUNI FROM COPYUNIONMESA WHERE NUMEROREVER = IN_NUMERO_REVER);

		-- =============================================
		-- ELIMINA LOS RESPALDO YA QUE HAN SIDO CARGADOS
		DELETE FROM TABCOPYINV00018
		WHERE NUMEROREVER = IN_NUMERO_REVER;

		DELETE FROM TABCOPYVEN0104
		WHERE NUMEROREVER = IN_NUMERO_REVER;

		DELETE FROM TABCOPYVEN0004
		WHERE NUMEROREVER = IN_NUMERO_REVER;

		DELETE FROM COPYUNIONMESA
		WHERE NUMEROREVER = IN_NUMERO_REVER;
		COMMIT;
	END SP_ACOMER_FACTURACION_REVER;

-- =============================================
-- SABER QUE PEDIDOS DE QUE MESA ESTAN LISTO PARA ENTREGAR
	PROCEDURE SP_ACOMER_PEDIDOS_ENTREGAR
	(
		CURSOR_PEDIDOS OUT SYS_REFCURSOR  -- CURSOR QUE TRAE LOS PEDIDOS QUE YA ESTAN LISTOS PARA ENTREGAR
	)
	AS
		V_COUNT NUMBER; -- CONTAR LOS REGISTROS 
	BEGIN
		SELECT COUNT(*)
		INTO V_COUNT
		FROM INV00018 INV1    
		INNER JOIN VEN0104 VEN1
		    ON INV1.MESNUMREQ = VEN1.PEDNUMDOC
		    OR INV1.MESNUMREQ2 = VEN1.PEDNUMDOC
		    OR INV1.MESNUMREQ3 = VEN1.PEDNUMDOC
		    OR INV1.MESNUMREQ4 = VEN1.PEDNUMDOC
		INNER JOIN VEN0004 VEN2
		    ON VEN1.PEDNRO = VEN2.PEDNRO
		WHERE VEN2.PEDSAL = 'T'
		ORDER BY VEN1.PEDEMPC;

		IF(V_COUNT = 0) THEN
			BEGIN
				OPEN CURSOR_PEDIDOS FOR
					SELECT 'NO' ESTADO,
					    'NO' MESA,
					    'NO' EMPRESA,
					    'NO' DOCUMENTO,
                    	'NO' PUESTO,
                    	'NO' PLATO
					FROM DUAL;
			END;
		ELSE
			BEGIN
				OPEN CURSOR_PEDIDOS FOR
					SELECT DISTINCT PEDSAL ESTADO,
	                    MESCOD MESA, PEDEMPC EMPRESA, 
	                    PEDNUMDOC DOCUMENTO,
	                    LISTAGG(TRIM(CCOCOD),'*_') WITHIN GROUP( ORDER BY TRIM(CCOCOD)) PUESTO,
	                    LISTAGG(TRIM(PEDPROCOD),'*_') WITHIN GROUP( ORDER BY TRIM(PEDPROCOD)) PLATO
	                FROM (
	                    SELECT VEN2.PEDSAL,
	                        VEN1.MESCOD,
	                        VEN1.PEDEMPC,
	                        VEN1.PEDNRO,
	                        VEN1.PEDNUMDOC,
	                        VEN2.CCOCOD,
	                        VEN2.PEDPROCOD                            
	                    FROM INV00018 INV1    
	                    INNER JOIN VEN0104 VEN1
	                        ON INV1.MESNUMREQ = VEN1.PEDNUMDOC
	                        OR INV1.MESNUMREQ2 = VEN1.PEDNUMDOC
	                        OR INV1.MESNUMREQ3 = VEN1.PEDNUMDOC
	                        OR INV1.MESNUMREQ4 = VEN1.PEDNUMDOC
	                    INNER JOIN VEN0004 VEN2
	                        ON VEN1.PEDNRO = VEN2.PEDNRO
	                    WHERE VEN2.PEDSAL = 'T'
	                    ORDER BY TO_DATE(INV1.MESHORAPED, 'HH24:MI:SS') ASC)
	                 GROUP BY PEDSAL, MESCOD, 
	                    PEDEMPC, PEDNUMDOC;
			END;
		END IF;		
	END SP_ACOMER_PEDIDOS_ENTREGAR;

-- =============================================
--	REALIZAR PEDIDOS DE UNA MESA 
	PROCEDURE SP_ACOMER_PEDIDOS
	(
		IN_PUESTOS_ARRAY IN OUT TYPE_PEDIDOS_ARRAY, 	 -- LOS PUESTOS DE DONDE FUERON SOLICITADOS LOS PEDIDOS
		IN_PRODUCTOS_ARRAY IN  OUT TYPE_PEDIDOS_ARRAY,   -- LOS CODIGOS DE LOS PRODUCTOS QUE SE ESTA PIDIENDO 
		IN_CANTIDAD_ARRAR IN OUT TYPE_PEDIDOS_ARRAY,	 -- LA CANTIDAD PEDIDA POR PRODDUCTO
		IN_TERMINO_ARRAY IN OUT TYPE_PEDIDOS_ARRAY,		 -- TERMINO DE LA COMIDA SI HA DE TENERLA 
		IN_CODIGO_MESERO IN SEG0001.USUCED%TYPE,		 -- CODIGO DEL MESERO 
		IN_CODIGO_MESA IN INV00018.MESCOD%TYPE      	 -- CODIGO DE LA MESA DONDE SE ESTA REALIZANDO DEL PEDIDO 	
	)
	AS
		V_CODIGO_RESTAURANTE VEN0001.VENEMPC%TYPE;  -- OBTENER Y PASAR CODIGOS DE LOS RESTAURANTES RESULTANTES DE LOS PRODUCTOS
		V_CODIGO_PEDIDOS_OUT  VEN0104.PEDNRO%TYPE; 	-- VARIABLE DE SALIDA DEL PROCEDIMIENTO SP_ACOMER_PEDIDOS_CAB
		V_CODIGO_PEDIDOS TYPE_PEDIDOS_ARRAY; 		-- ALMACENA LOS CODIGOS DE LOS PEDIDOS CREADOS 
		V_CONTADOR NUMBER := 1; 		   			-- CONTADOR PARA TENER LA CANTIDAD DE PEDIDOS
		V_VALIDACION NUMBER;						-- VALIDACION DE DATOS
		V_PROB VARCHAR2(200);
	BEGIN
	-- =============================================
	-- VALIDA QUE LA MESA INSERTADA EXISTE
		SELECT COUNT(*)
		INTO V_VALIDACION
		FROM INV00018
		WHERE MESCOD = IN_CODIGO_MESA;

		IF(V_VALIDACION = 0) THEN
			BEGIN
				RAISE_APPLICATION_ERROR(-20001, 'LA MESA INGRESADA "'||IN_CODIGO_MESA||'" NO ES VALIDA.');
			END;
		END IF;

	-- =============================================
	-- VALIDA QUE LOS PUESTOS SI EXISTEN 
		FOR I IN IN_PUESTOS_ARRAY.FIRST..IN_PUESTOS_ARRAY.LAST
		LOOP
			SELECT COUNT(*)
			INTO V_VALIDACION
			FROM GEN0009
			WHERE CCOCOD = CAST(IN_PUESTOS_ARRAY(I) AS CHAR(3));
			
			IF(V_VALIDACION = 0) THEN
				BEGIN
					RAISE_APPLICATION_ERROR(-20001, 'EL PUESTO INGRESADO "'||IN_PUESTOS_ARRAY(I)||'" NO ES VALIDO.');
				END;
			END IF;
		END LOOP;

	-- =============================================
	-- VALIDA QUE LOS PUESTOS SI EXISTEN 
		FOR I IN IN_PRODUCTOS_ARRAY.FIRST..IN_PRODUCTOS_ARRAY.LAST
		LOOP
			SELECT COUNT(*)
			INTO V_VALIDACION
			FROM VEN0001
			WHERE PROCOD = CAST(IN_PRODUCTOS_ARRAY(I) AS CHAR(20));
			
			IF(V_VALIDACION = 0) THEN
				BEGIN
					RAISE_APPLICATION_ERROR(-20001, 'EL ITEM INGRESADO "'||IN_PRODUCTOS_ARRAY(I)||'" NO ES VALIDO.');
				END;
			END IF;
		END LOOP;

	-- =============================================
	-- CONSUTO EL CODIGO DE LOS RESTAURANTE DONDE PERTENECE EL PRODUCTO
		FOR I IN IN_PRODUCTOS_ARRAY.FIRST..IN_PRODUCTOS_ARRAY.LAST
		LOOP
			-- CONSULTO EL CODIGO DEL RESTAURANTE AL Q PERTENECE EL PRODUCTO
			SELECT VENEMPC
			INTO V_CODIGO_RESTAURANTE
			FROM VEN0001
			WHERE PROCOD = CAST(IN_PRODUCTOS_ARRAY(I) AS CHAR(20));

			-- SE INSERTA EN LA TABLA TEMPORAL LOS CODIGOS DE LOS RESTAURANTES
			INSERT INTO TT_COD_RES (COD_RES)
			VALUES (V_CODIGO_RESTAURANTE);
			
		END LOOP;

	-- =============================================
	-- INSERTO LAS CABECERAS DE LOS PEDIDOS
		DECLARE
			CURSOR CURSOR_PEDIDOS IS
				SELECT DISTINCT COD_RES
				FROM TT_COD_RES;
		BEGIN
			OPEN CURSOR_PEDIDOS;
			LOOP	
				-- LEEMOS EL CURSOR 
				FETCH CURSOR_PEDIDOS INTO V_CODIGO_RESTAURANTE;
				--SALE DEL LOOP SI NO ENCUENTRA NADA EN EL CURSOR
				EXIT WHEN CURSOR_PEDIDOS%NOTFOUND;
				-- CREAMOS LA CABECERA DEL PEDIDO PARA CADA RESTAURANTE
				SP_ACOMER_PEDIDOS_CAB(V_CODIGO_RESTAURANTE, 'PD', IN_CODIGO_MESERO, IN_CODIGO_MESA, V_CODIGO_PEDIDOS_OUT);
				-- INSERTAMOS LOS CODIGOS DE PEDIDO GENERADOS EN LA CABECERA
				UPDATE TT_COD_RES
				SET COD_PED = V_CODIGO_PEDIDOS_OUT
				WHERE COD_RES = V_CODIGO_RESTAURANTE;
			END LOOP;
			CLOSE CURSOR_PEDIDOS;
		END;

	-- =============================================
	-- INSERTO EL DETALLE DE LOS PEDIDOS
		DECLARE
			CR_COD_RES TT_COD_RES.COD_RES%TYPE;  -- VARIABLE QUE TENDRA LOS VALORES LEIDOS DEL CURSOR
			CR_COD_PED TT_COD_RES.COD_PED%TYPE;	 -- VARIABLE QUE TENDRA LOS VALORES LEIDOS DEL CURSOR
			CR_VALIDA VEN0001.VENEMPC%TYPE;  	 -- COMPARAR VARIABLES
			CURSOR CURSOR_PEDIDOS_DET IS
				SELECT DISTINCT *
				FROM TT_COD_RES;
		BEGIN
			OPEN CURSOR_PEDIDOS_DET;
			LOOP
				-- LEEMOS EL CURSOR 
				FETCH CURSOR_PEDIDOS_DET INTO CR_COD_RES, CR_COD_PED;
				--SALE DEL LOOP SI NO ENCUENTRA NADA EN EL CURSOR
				EXIT WHEN CURSOR_PEDIDOS_DET%NOTFOUND;
				-- RECORREMOS LOS ITEMS E INSERTAMOS EN EL DETALLE DEL PEDIDO
				FOR I IN IN_PRODUCTOS_ARRAY.FIRST..IN_PRODUCTOS_ARRAY.LAST
				LOOP
					-- CONSULTAMOS EL CODIGO DEL RESTAURANTE AL QUE EL PRODUCTO O ITEM PERTENECE 
					SELECT VENEMPC
					INTO CR_VALIDA
					FROM VEN0001
					WHERE PROCOD = CAST(IN_PRODUCTOS_ARRAY(I) AS CHAR(20));
					-- SI LOS CODIGOS DE LOS RESTAURANTES COINCIDEN SE GUARDA EL DETALLE DEL PEDIDO
					IF(CR_VALIDA = CR_COD_RES) THEN
						BEGIN
							-- INSERTA EL DETALLE DEL PEDIDO 
							SP_ACOMER_PEDIDOS_DET(CR_COD_RES, 'PD', CR_COD_PED, IN_PRODUCTOS_ARRAY(I), IN_TERMINO_ARRAY(I),
							IN_PUESTOS_ARRAY(I), IN_CANTIDAD_ARRAR(I), IN_CODIGO_MESERO);
						END;
					END IF;
					
				END LOOP;
			END LOOP;
			CLOSE CURSOR_PEDIDOS_DET;
		END;

	-- MESUSUREQ  RESTAURANTE SMILLE CITY	901.023.461-1
	-- MESUSUREQ2 RESTAURANTE 				901.023.461-2
	-- MESUSUREQ3 RESTAURANTE
	-- MESUSUREQ4 RESTAURANTE
	-- =============================================
	-- ACTUALIZA LA MESA A OCUPADA UNA VEZ SE TOMA EL PEDIDO
		DECLARE	
			-- DATOS PARA EL MANEJO DEL CURSOR
			CR_COD_RES TT_COD_RES.COD_RES%TYPE;  -- VARIABLE QUE TENDRA LOS VALORES LEIDOS DEL CURSOR
			CR_COD_PED TT_COD_RES.COD_PED%TYPE;	 -- VARIABLE QUE TENDRA LOS VALORES LEIDOS DEL CURSOR
			CURSOR CURSOR_PEDIDOS_DET IS
				SELECT DISTINCT *
				FROM TT_COD_RES;
			-- DATOS PARA LA CONSULTA DEL NUMDOC
			V_NUMDOC VEN0104.PEDNUMDOC%TYPE; -- ALAMACENAR EL NUMERO DE DOCUMENTO DEL PEDIDO PARA LA MESA
		BEGIN
			OPEN CURSOR_PEDIDOS_DET;
			LOOP
				-- LEEMOS EL CURSOR 
				FETCH CURSOR_PEDIDOS_DET INTO CR_COD_RES, CR_COD_PED;
				--SALE DEL LOOP SI NO ENCUENTRA NADA EN EL CURSOR
				EXIT WHEN CURSOR_PEDIDOS_DET%NOTFOUND;

				-- =============================================
				-- CONSULTO EL NUMERO DEL DOCUMENTO ASIGANADO AL PEDIDO DE LA MESA
				SELECT PEDNUMDOC
				INTO V_NUMDOC
				FROM VEN0104
				WHERE PEDEMPC = CR_COD_RES
					AND PEDNRO = CR_COD_PED
					AND MESCOD = IN_CODIGO_MESA;

				-- COMPARAMOS LOS CODIGOS DE LOS RESTAURANTES Y ACTUALIZAMOS LOS NUMEROS DE LOS PEDIDOS EN LAS MESAS 
				CASE CR_COD_RES
					WHEN PKG_CONTAINER1 THEN
						BEGIN
							UPDATE INV00018
							SET MESESTADO = 'Ocupado',
							    MESUSUREQ = IN_CODIGO_MESERO,
							    MESDOCREQ = 'PD',
							    MESNUMREQ = V_NUMDOC,
							    MESHORAPED = TO_CHAR(SYSDATE,'HH24:MI:SS')
							WHERE MESCOD = IN_CODIGO_MESA;
						END;

					WHEN PKG_CONTAINER2 THEN
						BEGIN
							UPDATE INV00018
							SET MESESTADO = 'Ocupado',
							    MESUSUREQ = IN_CODIGO_MESERO,
							    MESDOCREQ = 'PD',
							    MESNUMREQ2 = V_NUMDOC,
							    MESHORAPED = TO_CHAR(SYSDATE,'HH24:MI:SS')
							WHERE MESCOD = IN_CODIGO_MESA;
						END;

					WHEN PKG_CONTAINER3 THEN
						BEGIN
							UPDATE INV00018
							SET MESESTADO = 'Ocupado',
							    MESUSUREQ = IN_CODIGO_MESERO,
							    MESDOCREQ = 'PD',
							    MESNUMREQ3 = V_NUMDOC,
							    MESHORAPED = TO_CHAR(SYSDATE,'HH24:MI:SS')
							WHERE MESCOD = IN_CODIGO_MESA;
						END;

					WHEN PKG_CONTAINER4 THEN
						BEGIN
							UPDATE INV00018
							SET MESESTADO = 'Ocupado',
							    MESUSUREQ = IN_CODIGO_MESERO,
							    MESDOCREQ = 'PD',
							    MESNUMREQ4 = V_NUMDOC,
							    MESHORAPED = TO_CHAR(SYSDATE,'HH24:MI:SS')
							WHERE MESCOD = IN_CODIGO_MESA;
						END;				
				END CASE;
				
			END LOOP;
			CLOSE CURSOR_PEDIDOS_DET;
		END;	
	END SP_ACOMER_PEDIDOS;

-- =============================================
-- SABER CUAL ES LA MESA PRINCIPAL  CUALES ESGAN UNIDAS A ELLA
	PROCEDURE SP_ACOMER_MESAS_UNIDAS
	(
		IN_CODIGO_MESA IN DETMESA.MESCOD%TYPE, -- CODIGO DE LA MESA QUE SE VA A BUSCAR SUS UNIONES
		OUT_MESAS_UNIDAS OUT SYS_REFCURSOR,    -- CURSOR QUE CONTIENE LAS MESAS QUE VAN UNIDAD EN LA MESA CLICKEADA
		OUT_MESA_PRINCIPAL OUT DETMESA.MESCOD%TYPE  -- CODIGO DE LA MESA PRINCIPAL
	)
	AS
		V_MESA_PRINCIPAL DETMESA.MESCOD%TYPE;
	BEGIN
		-- ================================
		-- CONSULTO LAS MESAS UNIDAD A LA PRINCIPAL 	
		BEGIN
			SELECT DISTINCT 1
			INTO V_MESA_PRINCIPAL	 
			FROM UNIONMESA
			WHERE MESCOD = IN_CODIGO_MESA;
		EXCEPTION
			WHEN OTHERS THEN
				V_MESA_PRINCIPAL := 0;
		END;

		-- ==============================
		-- SI NO ES MESA PRINCIPAL BUSCO CUAL ES 
		IF(V_MESA_PRINCIPAL = 0) THEN		
			-- ========================
			-- CONSULTA LA MESA PRINCIPAL
			SELECT DISTINCT MESCOD
			INTO V_MESA_PRINCIPAL
			FROM UNIONMESA
			WHERE MESCODUNI = IN_CODIGO_MESA;

			-- =========================
			-- CONSULTA DE LAS MESAS
			OPEN OUT_MESAS_UNIDAS FOR
				SELECT DISTINCT MESCODUNI		
				FROM UNIONMESA
				WHERE MESCOD = V_MESA_PRINCIPAL
				ORDER BY MESCOD;

			--
			OUT_MESA_PRINCIPAL := V_MESA_PRINCIPAL;
		ELSE
			-- ========================
			-- CONSULTA DE LAS MESAS
			OPEN OUT_MESAS_UNIDAS FOR
				SELECT DISTINCT MESCODUNI		
				FROM UNIONMESA
				WHERE MESCOD = IN_CODIGO_MESA
				ORDER BY MESCOD;

			--
			OUT_MESA_PRINCIPAL := IN_CODIGO_MESA;
		END IF;
		
	END SP_ACOMER_MESAS_UNIDAS;

-- =============================================
-- ADICIONAR PEDIDOS A UNA MESA
	PROCEDURE SP_ACOMER_PEDIDOS_ADD
	(	
		IN_PUESTOS_ARRAY IN OUT TYPE_PEDIDOS_ARRAY, 	 -- LOS PUESTOS DE DONDE FUERON SOLICITADOS LOS PEDIDOS
		IN_PRODUCTOS_ARRAY IN  OUT TYPE_PEDIDOS_ARRAY,   -- LOS CODIGOS DE LOS PRODUCTOS QUE SE ESTA PIDIENDO 
		IN_CANTIDAD_ARRAR IN OUT TYPE_PEDIDOS_ARRAY,	 -- LA CANTIDAD PEDIDA POR PRODDUCTO
		IN_TERMINO_ARRAY IN OUT TYPE_PEDIDOS_ARRAY,		 -- TERMINO DE LA COMIDA SI HA DE TENERLA 
		IN_CODIGO_MESERO IN SEG0001.USUCED%TYPE,		 -- CODIGO DEL MESERO 
		IN_CODIGO_MESA IN INV00018.MESCOD%TYPE      	 -- CODIGO DE LA MESA DONDE SE ESTA REALIZANDO DEL PEDIDO 	
	)
	AS
		V_CODIGO_RESTAURANTE VEN0001.VENEMPC%TYPE;  -- OBTENER Y PASAR CODIGOS DE LOS RESTAURANTES RESULTANTES DE LOS PRODUCTOS
		V_CODIGO_PEDIDOS_OUT  VEN0104.PEDNRO%TYPE; 	-- VARIABLE DE SALIDA DEL PROCEDIMIENTO SP_ACOMER_PEDIDOS_CAB	
		V_CONTADOR NUMBER := 0; 		   			-- CONTADOR PARA TENER LA CANTIDAD DE PEDIDOS
		V_VALIDACION NUMBER;						-- VALIDACION DE DATOS
		ARRAY_PEDIDOS_NEW TYPE_PEDIDOS_ARRAY; -- POSICION DE LOS ITEM DE RESTAURANTES QUE NO TIENEN PEDIDOS	
		V_BOOLEAN BOOLEAN := FALSE; 
	BEGIN
	-- =============================================
	-- VALIDA QUE LA MESA INSERTADA EXISTE
		SELECT COUNT(*)
		INTO V_VALIDACION
		FROM INV00018
		WHERE MESCOD = IN_CODIGO_MESA;

		IF(V_VALIDACION = 0) THEN
			BEGIN
				RAISE_APPLICATION_ERROR(-20001, 'LA MESA INGRESADA "'||IN_CODIGO_MESA||'" NO ES VALIDA.');
			END;
		END IF;

	-- =============================================
	-- VALIDA QUE LOS PUESTOS SI EXISTEN 
		FOR I IN IN_PUESTOS_ARRAY.FIRST..IN_PUESTOS_ARRAY.LAST
		LOOP
			SELECT COUNT(*)
			INTO V_VALIDACION
			FROM GEN0009
			WHERE CCOCOD = CAST(IN_PUESTOS_ARRAY(I) AS CHAR(3));
			
			IF(V_VALIDACION = 0) THEN
				BEGIN
					RAISE_APPLICATION_ERROR(-20001, 'EL PUESTO INGRESADO "'||IN_PUESTOS_ARRAY(I)||'" NO ES VALIDO.');
				END;
			END IF;
		END LOOP;

	-- =============================================
	-- VALIDA QUE LOS PRODUCTOS SI EXISTEN 
		FOR I IN IN_PRODUCTOS_ARRAY.FIRST..IN_PRODUCTOS_ARRAY.LAST
		LOOP
			SELECT COUNT(*)
			INTO V_VALIDACION
			FROM VEN0001
			WHERE PROCOD = CAST(IN_PRODUCTOS_ARRAY(I) AS CHAR(20));
			
			IF(V_VALIDACION = 0) THEN
				BEGIN
					RAISE_APPLICATION_ERROR(-20001, 'EL ITEM INGRESADO "'||IN_PRODUCTOS_ARRAY(I)||'" NO ES VALIDO.');
				END;
			END IF;
		END LOOP;

	-- =============================================
	-- COMPRAR LOS PEDIDOS DE LOS RESTAURANTES DE LA MESAS	
		DECLARE
			V_NUMDOC1 INV00018.MESNUMREQ%TYPE;
			V_NUMDOC2 INV00018.MESNUMREQ2%TYPE;
			V_NUMDOC3 INV00018.MESNUMREQ3%TYPE;
			V_NUMDOC4 INV00018.MESNUMREQ4%TYPE;
			V_ESTADO VARCHAR2(1);
			V_CONTADOR NUMBER := 1;
		BEGIN
			-- SE CONSULTA LOS NUMEROS DE PEDIDOS QUE TIENE LA MESA ACTUALMENTE
			SELECT MESNUMREQ,MESNUMREQ2,
			    MESNUMREQ3, MESNUMREQ4
			INTO V_NUMDOC1, V_NUMDOC2,
				V_NUMDOC3, V_NUMDOC4
			FROM INV00018
			WHERE MESCOD = IN_CODIGO_MESA;

			FOR I IN IN_PRODUCTOS_ARRAY.FIRST..IN_PRODUCTOS_ARRAY.LAST
			LOOP
				-- CONSULTA EL CODIGO DEL RESTAURANTE AL QUE PERTENECE EL PRODUCTO 
				SELECT VENEMPC
				INTO V_CODIGO_RESTAURANTE
				FROM VEN0001
				WHERE PROCOD = CAST(IN_PRODUCTOS_ARRAY(I) AS CHAR(20));

				-- COMPARA QUE EL RESTAURANTE AL QUE PERTENECE EL ELEMENTO PEDIDO, TENGA PEDIDO EN LA MESA
				BEGIN
					SELECT DISTINCT '1' ESTADO
					INTO V_ESTADO
				    FROM DUAL
				    WHERE V_CODIGO_RESTAURANTE IN (SELECT PEDEMPC
				                                   FROM VEN0104 
				                                   WHERE PEDNUMDOC IN (V_NUMDOC1,V_NUMDOC2,V_NUMDOC3,V_NUMDOC4)
				                                        AND MESCOD = IN_CODIGO_MESA);
				EXCEPTION
					WHEN NO_DATA_FOUND THEN
						V_ESTADO := '0';
				END;
				-- SI YA HAY UN PEDIDO A ESE RESTAURANTE SE AGREGA EL ITEM A ESE PEDIDO 
				CASE V_ESTADO
					WHEN '1' THEN 	
						DECLARE
							V_PEDNRO VEN0104.PEDNRO%TYPE; -- ALMACENARA EL CODIGO DEL PEDIDO	
							V_REPETIDO NUMBER;			  -- VERIFICAR QUE 	
						BEGIN
							-- CONSULTO EL NUMERO DEL PEDIDO QUE TIENE ESA MESA EN EL RESTAURANTE 
							SELECT PEDNRO
							INTO V_PEDNRO
							FROM VEN0104
							WHERE PEDEMPC = V_CODIGO_RESTAURANTE 
							    AND PEDNUMDOC IN (V_NUMDOC1,V_NUMDOC2,V_NUMDOC3,V_NUMDOC4);

							-- CONSULTO SI EL ITEM YA HA SIDO PEDIDO O ES PRIMERA VEZ EN LA MESA Y EL PUESTO
							SELECT COUNT(*)
							INTO V_REPETIDO
							FROM VEN0004
							WHERE PEDPROCOD = CAST(IN_PRODUCTOS_ARRAY(I) AS CHAR(20))
	            				AND PEDNRO = V_PEDNRO
	            				AND CCOCOD = CAST(IN_PUESTOS_ARRAY(I) AS CHAR(20));

	            			--RAISE_APPLICATION_ERROR(-20001, 'CANTIDAD: '||TO_CHAR(V_REPETIDO));
	            			-- SI ESTA REPETIDO SE ACTUALIZA , SI NO SE AGREGA AL PEDIDO EL NUEVO ITEM
	            			IF(V_REPETIDO = 1) THEN
	            				BEGIN
	            					SP_ACOMER_PEDIDOS_ACT(
	            						IN_PRODUCTOS_ARRAY(I),
	            						V_PEDNRO, 
	            						IN_PUESTOS_ARRAY(I),
	            						IN_CANTIDAD_ARRAR(I));
	            				END;
	            			ELSE 
	            				BEGIN
	            					SP_ACOMER_PEDIDOS_DET(
	            						V_CODIGO_RESTAURANTE,
		            					'PD',
		            					V_PEDNRO,
		            					IN_PRODUCTOS_ARRAY(I),
		            					IN_TERMINO_ARRAY(I),
		            					IN_PUESTOS_ARRAY(I),
		            					IN_CANTIDAD_ARRAR(I),
		            					IN_CODIGO_MESERO);
	            				END;
	            			END IF;
						END;

					ELSE
						BEGIN
							V_BOOLEAN := TRUE;
							V_CONTADOR := V_CONTADOR + 1;
							ARRAY_PEDIDOS_NEW(V_CONTADOR) := I;							
						END;
				END CASE;
			END LOOP;

			-- SE AGREGAN LAS NUEVAS CABECERAS DE NO EXISTIR UN PEDIDO EN EL RESTAURANTE
			IF(V_BOOLEAN) THEN
				DECLARE
					ARRAY_PUESTOS TYPE_PEDIDOS_ARRAY;
					ARRAY_PRODUCTOS TYPE_PEDIDOS_ARRAY;
					ARRAY_CANTIDAD TYPE_PEDIDOS_ARRAY;
					ARRAY_TERMINO TYPE_PEDIDOS_ARRAY;
				BEGIN
					-- SE ASIGNAN LOS PEDIDOS QUE NO TIENE UNA CABECERA EN PEDIDO 
					FOR I IN ARRAY_PEDIDOS_NEW.FIRST..ARRAY_PEDIDOS_NEW.LAST
					LOOP
						ARRAY_PUESTOS(I) := IN_PUESTOS_ARRAY(ARRAY_PEDIDOS_NEW(I));
						ARRAY_PRODUCTOS(I) := IN_PRODUCTOS_ARRAY(ARRAY_PEDIDOS_NEW(I));
						ARRAY_CANTIDAD(I) := IN_CANTIDAD_ARRAR(ARRAY_PEDIDOS_NEW(I));
						ARRAY_TERMINO(I) := IN_TERMINO_ARRAY(ARRAY_PEDIDOS_NEW(I));
					END LOOP;

					--SE EJECUTA EL PROCEDIMIENTO DESDE CERO
					SP_ACOMER_PEDIDOS(ARRAY_PUESTOS,ARRAY_PRODUCTOS,ARRAY_CANTIDAD,ARRAY_TERMINO,IN_CODIGO_MESERO,IN_CODIGO_MESA);

				END;
			END IF;
		END;

		-- ACTUALIZA LA HORA DE ATENCION
		UPDATE INV00018
		SET MESHORAPED = TO_CHAR(SYSDATE,'HH24:MI:SS')
		WHERE MESCOD = IN_CODIGO_MESA;
	END SP_ACOMER_PEDIDOS_ADD;

-- =============================================
-- UNIR MESAS CON LA RESPECTIVA CANTIDAD DE PUESTOS NECESARIOS
	PROCEDURE SP_ACOMER_UNION_MESAS
	(
		IN_MESA IN DETMESA.MESCOD%TYPE,			  -- CODIGO DE LA MESA
		IN_PUESTOS IN DETMESA.PUESTOS%TYPE, 	  -- CANTIDAD DE PUESTOS QUE SE VAN A USA 	
		IN_MESAS_ARRAY IN OUT TYPE_PEDIDOS_ARRAY  -- MESAS QUE SE UNEN
	)
	AS
		V_MESAS_UNIDAS VARCHAR2(10) := '';
	BEGIN
		-- SE ACTUALIZA LA TABLA QUE TIENE LA MESAS QUE SE UNIERON
		FOR I IN IN_MESAS_ARRAY.FIRST..IN_MESAS_ARRAY.LAST
		LOOP
			INSERT INTO UNIONMESA (MESCOD, MESCODUNI)
			VALUES(IN_MESA, TO_NUMBER(IN_MESAS_ARRAY(I)));
			--
			UPDATE DETMESA
			SET PUESTOS = IN_PUESTOS
			WHERE MESCOD = IN_MESAS_ARRAY(I);
		END LOOP;

		-- ACTUALIZA LA CANTIDAD DE PUESTOS SELECCIONADOSEN LA MESA
		UPDATE DETMESA
		SET PUESTOS = IN_PUESTOS
		WHERE MESCOD = IN_MESA;

	END SP_ACOMER_UNION_MESAS;

-- =============================================
-- DETALLE DEL PEDIDO DE LA MESA
	PROCEDURE SP_ACOMER_DETALLE_PEDIDO
	(
		IN_CODIGO_MESA IN VEN0104.MESCOD%TYPE, -- CODIGO DE LA MESA QUE HA HECHO PEDIDO
		OUT_CURSOR OUT SYS_REFCURSOR
	)
	AS
		V_PEDIDO1 INV00018.MESNUMREQ%TYPE; -- CODIGO DEL PEDIDO AL RESTAURANTE 1 SI HA DE TENER PEDIDOS  
		V_PEDIDO2 INV00018.MESNUMREQ%TYPE; -- CODIGO DEL PEDIDO AL RESTAURANTE 2 SI HA DE TENER PEDIDOS 
		V_PEDIDO3 INV00018.MESNUMREQ%TYPE; -- CODIGO DEL PEDIDO AL RESTAURANTE 3 SI HA DE TENER PEDIDOS 
		V_PEDIDO4 INV00018.MESNUMREQ%TYPE; -- CODIGO DEL PEDIDO AL RESTAURANTE 4 SI HA DE TENER PEDIDOS 
	BEGIN
	-- ======================
	-- CONSULTA CODIGO DE PEDIDOS DE LA MESA
		SELECT MESNUMREQ, MESNUMREQ2, 
			MESNUMREQ3, MESNUMREQ4
		INTO V_PEDIDO1, V_PEDIDO2,
			V_PEDIDO3, V_PEDIDO4
		FROM INV00018
		WHERE MESCOD = IN_CODIGO_MESA;

	-- =====================
	-- CONSULTA 
		OPEN OUT_CURSOR FOR
			SELECT DISTINCT C.PRODES PLATO, 
			    A.PEDUNI CANTIDAD,
			    SUBSTR(A.CCOCOD,2) PUESTO,
			    C.PROCOD CODIGO,
			    D.CATIMG IMAGEN
			FROM VEN0004 A
			INNER JOIN VEN0104 B
			    ON A.PEDNRO = B.PEDNRO
			    AND B.PEDNUMDOC IN (V_PEDIDO1,V_PEDIDO2,V_PEDIDO3,V_PEDIDO4)
			INNER JOIN VEN0001 C
			    ON A.PEDPROCOD = C.PROCOD
			INNER JOIN INV0013 D
	      		ON C.VENCATCOD = D.CATECOD
			WHERE A.PEDSAL NOT IN ('F','C');
	END SP_ACOMER_DETALLE_PEDIDO;

-- =============================================
-- NOMBRE DEL PLATO QUE ES INGRESADO.
	PROCEDURE SP_ACOMER_NOMBRE_PLATOS
	(
		IN_CODIGO_PLATO IN VEN0001.PROCOD%TYPE, -- CODIGO DEL PLATO QUE SE CONSULTA
		OUT_NOMBRE_PLATO OUT VEN0001.PRODES%TYPE, -- NOMBRE DEL PLATO
		OUT_NOMBRE_IMAGEN OUT INV0013.CATIMG%TYPE
	)
	AS
	BEGIN
		-- CONSULTA EL NOMBRE DEL PLATO CON EL CODIGO CORRESPONDIENTE
		SELECT DISTINCT A.PRODES, B.CATIMG
		INTO OUT_NOMBRE_PLATO, OUT_NOMBRE_IMAGEN
		FROM VEN0001 A
		INNER JOIN INV0013 B
			ON A.VENCATCOD = B.CATECOD
		WHERE PROCOD = IN_CODIGO_PLATO;

	END SP_ACOMER_NOMBRE_PLATOS;

-- =============================================
-- CANCELAR PEDIDOS QUE YA ESTAN CONFIRMADOS
	PROCEDURE SP_ACOMER_PEDIDOS_CANCEL
	(
		IN_TIPO_CANCELAR IN NUMBER,			 		  -- MODO QUE SE CANCELA EL PEIDO
		IN_CODIGO_MESA IN INV00018.MESCOD%TYPE, 	  -- CODIGO DE LA MESA DONDE SE VA A CANCELAR EL PEDIDO
		IN_PLATOS_CANCELAR IN OUT TYPE_PEDIDOS_ARRAY, -- CODIGO DE LOS PLATOS QUE SE CANCELAN
		IN_CANTIDAD IN OUT TYPE_PEDIDOS_ARRAY,        -- CANTIDAD POR PLATO QUE SE CANCELAN 
		IN_PUESTO IN OUT TYPE_PEDIDOS_ARRAY, 		  -- PUESTO DONDE CANCELAN EL PEDIDO
		OUT_CODIGO_MENSAJE OUT NUMBER -- CODIGO DE MENSAJE
	)
	AS
		V_PEDIDO1 INV00018.MESNUMREQ%TYPE;   	-- CODIGO DE LOS PEDISO QUE HAY SOBRE LA MESA
		V_PEDIDO2 INV00018.MESNUMREQ2%TYPE;  	-- CODIGO DE LOS PEDISO QUE HAY SOBRE LA MESA
		V_PEDIDO3 INV00018.MESNUMREQ3%TYPE;  	-- CODIGO DE LOS PEDISO QUE HAY SOBRE LA MESA
		V_PEDIDO4 INV00018.MESNUMREQ4%TYPE;  	-- CODIGO DE LOS PEDISO QUE HAY SOBRE LA MESA
		V_CONTADOR NUMBER;
		V_NUM_PEDIDO VEN0004.PEDNRO%TYPE;	 	-- NUMERO DEL PEDIDO AL QUE PERTENCE EL PLATO A CANCELAR
		V_CANT_PEDIDO NUMBER;				 	-- CANTIDAD DE LO QUE YA SE HABIA PEDIDO
		V_CANT_FALTAN NUMBER;				 	-- CANTIDAD DE PLATOS QUE FALTA POR ENTREGAR 
		V_CODIGO_EMPRESA VEN0004.PEDEMPC%TYPE;	-- CODIGO DE LA MESA AL QUE PERTENCE EL NUMERO DE PEDIDO 
		V_CANTIDAD VEN0004.PEDUNI%TYPE;   			-- CANTIDAD TOTAL DE LO PEDIDO
		V_VALOR_ITEM_IVA VEN0004.PEDVALIVA%TYPE;	-- VALOR DEL ITEM CON IVA
		V_PRECIO_ITEM VEN0004.PEDVALIVA%TYPE;		-- VALOR DEL ITEM CON IVA
		V_RFPORDTO VEN0001.RFPORDTO%TYPE;			-- RFPORDTO 
		V_VALDESC VEN0004.peddcval%TYPE;			-- peddcval
		V_ESTADO_PED VEN0004.PEDSAL%TYPE;			-- ESTADO DEL PEDIDO
	BEGIN
		OUT_CODIGO_MENSAJE := 0;

		-- ==============================================
		-- CONSULTO LOS PEDIDOS QUE ESTAN EN  
		SELECT MESNUMREQ, MESNUMREQ2, MESNUMREQ3, MESNUMREQ4
		INTO V_PEDIDO1, V_PEDIDO2, V_PEDIDO3, V_PEDIDO4
		FROM INV00018
		WHERE MESCOD = IN_CODIGO_MESA;

		-- TIPO DE CANCELACION
		-- 1 = CANCELA TODO EL PEIDO
		-- 0 = CANCELA PARTE DEL PEDIDO
		IF (IN_TIPO_CANCELAR = 1) THEN		
			BEGIN			
				DECLARE 					
					ARRAY_CODIGOS_EMP TYPE_PEDIDOS_ARRAY; -- ARRAY DE LOS CODIGOS DE LOS CONTAINER
					ARRAY_NUMEROS_PED TYPE_PEDIDOS_ARRAY; -- ARRAY DE LOS NUMEROS DE LOS PEDIDOS
					V_CONTADOR_ENTREGADOS NUMBER := 0;	  -- IDENTIFICAR SI YA SE HA ENTREGADO UN PEDIDO
				BEGIN
					-- ==========================================
					-- LLENA EL ARRAY CON LOS CODIGOS DE LOS CONTAINER
					ARRAY_CODIGOS_EMP(1) := PKG_CONTAINER1;
					ARRAY_CODIGOS_EMP(2) := PKG_CONTAINER2;
					ARRAY_CODIGOS_EMP(3) := PKG_CONTAINER3;
					ARRAY_CODIGOS_EMP(4) := PKG_CONTAINER4;

					-- ==========================================
					-- SE LLENA EL ARRAY CON LOS NUMEROS DE PEDIDOS DE LA MESA
					SELECT MESNUMREQ, MESNUMREQ2,
    					MESNUMREQ3, MESNUMREQ4
    				INTO ARRAY_NUMEROS_PED(1), ARRAY_NUMEROS_PED(2),
    					ARRAY_NUMEROS_PED(3), ARRAY_NUMEROS_PED(4)
    				FROM INV00018
    				WHERE MESCOD = CAST(IN_CODIGO_MESA AS NUMBER);

    				-- ==========================================
    				-- SE HACE EL CONTEO DE CUANTOS PEDIDOS HAN SIDO ENTREGADOS 
    				FOR I IN ARRAY_NUMEROS_PED.FIRST..ARRAY_NUMEROS_PED.LAST
    				LOOP
    					BEGIN
    						SELECT NVL(SUM(PEDUNI),0) - NVL(SUM(PEDCHECK),0) + V_CONTADOR_ENTREGADOS TOTAL_ENTREGADOS
	    					INTO V_CONTADOR_ENTREGADOS
							FROM VEN0004 A
							INNER JOIN VEN0104 B
							    ON A.PEDNRO = B.PEDNRO
							    AND B.PEDEMPC = CAST(ARRAY_CODIGOS_EMP(I) AS CHAR(13))
							    AND B.PEDNUMDOC = CAST(ARRAY_NUMEROS_PED(I) AS CHAR(10));						
    					END;
    				END LOOP;

    				-- ==========================================
    				-- SI NO HAY PEDIDOS ENTREGADOS DE LA MESA SE CANCEL EL PEDIDO
    				IF(V_CONTADOR_ENTREGADOS = 0) THEN 
    					BEGIN
    						FOR I IN ARRAY_NUMEROS_PED.FIRST..ARRAY_NUMEROS_PED.LAST
		    				LOOP
		    					IF (ARRAY_NUMEROS_PED(I) <> ' ') THEN 
		    						-- ==========================================
									-- SE ACTUALIZA EL PEDIDO CANCELADO PARA CAMBIAR LUEGO DE TABLA
		    						UPDATE VEN0104
									SET PEDMODCOD = 'CANCEL'
									WHERE PEDEMPC = CAST(ARRAY_CODIGOS_EMP(I) AS CHAR(13))
							    		AND PEDNUMDOC = CAST(ARRAY_NUMEROS_PED(I) AS CHAR(10));

							    	-- SE ACTUALIZA EL DETALLE DEL PEDIDO CANCELADO 
							    	UPDATE VEN0004
									SET PEDSAL = 'C'
									WHERE PEDNRO IN (	SELECT DISTINCT A.PEDNRO 
														FROM VEN0004 A
														INNER JOIN VEN0104 B
															ON A.PEDNRO = B.PEDNRO
															AND B.PEDEMPC = CAST(ARRAY_CODIGOS_EMP(I) AS CHAR(13))
							    							AND B.PEDNUMDOC = CAST(ARRAY_NUMEROS_PED(I) AS CHAR(10))
							    					)
										AND PEDEMPC = CAST(ARRAY_CODIGOS_EMP(I) AS CHAR(13));

									-- ==========================================
							    	-- SE CAMBIA A LA TABLA CANCELADOS
							    	INSERT INTO PEDCAN
							    	SELECT * 
							    	FROM VEN0104
							    	WHERE PEDEMPC = CAST(ARRAY_CODIGOS_EMP(I) AS CHAR(13))
							    		AND PEDNUMDOC = CAST(ARRAY_NUMEROS_PED(I) AS CHAR(10));

							    	-- SE CAMBIA A LA TABLA CANCELADOS 
							    	INSERT INTO PEDDETCAN
							    	SELECT * 
							    	FROM VEN0004
							    	WHERE PEDNRO IN (	SELECT DISTINCT A.PEDNRO 
														FROM VEN0004 A
														INNER JOIN VEN0104 B
															ON A.PEDNRO = B.PEDNRO
															AND B.PEDEMPC = CAST(ARRAY_CODIGOS_EMP(I) AS CHAR(13))
							    							AND B.PEDNUMDOC = CAST(ARRAY_NUMEROS_PED(I) AS CHAR(10))
							    					)
										AND PEDEMPC = CAST(ARRAY_CODIGOS_EMP(I) AS CHAR(13));

									-- ==========================================
							    	-- SE ELIINAN LOS PLATOS QUE SE CANCELAN DE LA TABLA
							    	DELETE 
									FROM VEN0004
									WHERE PEDNRO IN (	SELECT DISTINCT A.PEDNRO 
														FROM VEN0004 A
														INNER JOIN VEN0104 B
															ON A.PEDNRO = B.PEDNRO
															AND B.PEDEMPC = CAST(ARRAY_CODIGOS_EMP(I) AS CHAR(13))
							    							AND B.PEDNUMDOC = CAST(ARRAY_NUMEROS_PED(I) AS CHAR(10))
							    					)
										AND PEDEMPC = CAST(ARRAY_CODIGOS_EMP(I) AS CHAR(13));
		    					END IF;
		    				END LOOP;

		    				-- SE LIBERA LA MESA 
		    				UPDATE INV00018
							SET MESNUMREQ = '',
								MESNUMREQ2 = '',
								MESNUMREQ3 = '',
								MESNUMREQ4 = '',
								MESUSUREQ = '',
								MESDOCREQ = '',
								MESESTADO = 'Activo',
								MESHORAPED = ''
							WHERE MESCOD = IN_CODIGO_MESA;
    					END;
    				ELSE 
    					BEGIN
    						-- SE INFORMA DE QUE HAY PEDIDOS YA ENTREGADOS QUE NO PUEDEN SER CANCELADOS
    						OUT_CODIGO_MENSAJE := 1;
    					END;
    				END IF;
				END;
			END;
		ELSE		
			BEGIN
				-- ==============================================
				-- RECORRE LOS PLATOS QUE SE VAN A CANCELAR
				FOR I IN IN_PLATOS_CANCELAR.FIRST..IN_PLATOS_CANCELAR.LAST
				LOOP
					-- NUMERO DE PEDIDO DEL PLATO QUE SE CANCELA 
					SELECT VEN0004.PEDNRO
					INTO V_NUM_PEDIDO
					FROM VEN0004
					INNER JOIN VEN0104 
	    				ON VEN0004.PEDNRO = VEN0104.PEDNRO   
					WHERE PEDPROCOD = CAST(IN_PLATOS_CANCELAR(I) AS CHAR(20))
						AND MESCOD = CAST(IN_CODIGO_MESA AS NUMBER)
					    AND CCOCOD =  CAST(IN_PUESTO(I) AS CHAR(3))
					    AND PEDSAL != 'C'
					    AND PEDSAL != 'F';
					-- CANTIDAD DE LO PEDIDO, LA CANTIDAD QUE FALTA POR ENTREGAR
					SELECT TO_NUMBER(PEDUNI), PEDCHECK
					INTO V_CANT_PEDIDO, V_CANT_FALTAN
					FROM VEN0004
					INNER JOIN VEN0104 
	    				ON VEN0004.PEDNRO = VEN0104.PEDNRO    
					WHERE CCOCOD = CAST(IN_PUESTO(I) AS CHAR(3))
						AND PEDPROCOD = CAST(IN_PLATOS_CANCELAR(I) AS CHAR(20))
						AND MESCOD = CAST(IN_CODIGO_MESA AS NUMBER)
						AND PEDSAL != 'C'
						AND PEDSAL != 'F';
					-- CANTIDAD DE PEDIDOS CON ESE NUMERO DE PEDIDO 
					SELECT COUNT(*)
					INTO V_CONTADOR
					FROM VEN0004 
					WHERE PEDNRO = V_NUM_PEDIDO
						AND PEDSAL IN ('N','E','T');
					-- ==============================================
					-- SI ES EL UNICO PEDIDO AL RESTAURATE ES CANCELADO, SE CANCELA EL DETALLE Y LA CABECERA
					IF (IN_CANTIDAD(I) = V_CANT_FALTAN AND V_CONTADOR = 1 AND V_CANT_PEDIDO = V_CANT_FALTAN) THEN
						BEGIN							
							-- SE ACTUALIZA EL DETALLE DEL PEDIDO COLOCANDOLO CANCELADO
							UPDATE VEN0004
							SET PEDSAL = 'C'
							WHERE PEDNRO = V_NUM_PEDIDO
								AND CCOCOD =  CAST(IN_PUESTO(I) AS CHAR(3));
							-- SE ACTUALIZA LA CABECERA DEL PEDIDO COLOCANDOLO CANCELADO
							UPDATE VEN0104
							SET PEDMODCOD = 'CANCEL'
							WHERE PEDNRO = V_NUM_PEDIDO;
							-- CONSULTO EL CODIGO DE LA EMPRESA QUE TIENE EL PEDIDO QUE SE VA A CANCELAR
							SELECT DISTINCT PEDEMPC 
							INTO V_CODIGO_EMPRESA
							FROM VEN0004
							WHERE PEDNRO = V_NUM_PEDIDO;
							-- QUITA EL NUMERO DEL PEDIO DE LA MESA
							CASE V_CODIGO_EMPRESA
								WHEN PKG_CONTAINER1 THEN
									BEGIN
										UPDATE INV00018
										SET MESNUMREQ = ''
										WHERE MESCOD = IN_CODIGO_MESA;
									END;

								WHEN PKG_CONTAINER2 THEN
									BEGIN
										UPDATE INV00018										
										SET MESNUMREQ2 = ''
										WHERE MESCOD = IN_CODIGO_MESA;
									END;

								WHEN PKG_CONTAINER3 THEN
									BEGIN
										UPDATE INV00018										
										SET MESNUMREQ3 = ''
										WHERE MESCOD = IN_CODIGO_MESA;
									END;

								WHEN PKG_CONTAINER4 THEN
									BEGIN
										UPDATE INV00018										
										SET MESNUMREQ4 = ''
										WHERE MESCOD = IN_CODIGO_MESA;
									END;
							END CASE;							
							--SE GUARDAN LOS DATOS DEL PEDIDO EN TABLA DE CANCELADOS
							INSERT INTO PEDCAN
							SELECT * 
							FROM VEN0104
							WHERE PEDNRO = V_NUM_PEDIDO;

							INSERT INTO PEDDETCAN
					    	SELECT * 
					    	FROM VEN0004
					    	WHERE PEDNRO = V_NUM_PEDIDO
								AND CCOCOD =  CAST(IN_PUESTO(I) AS CHAR(3));				

							--SE ELIMINAN LOS REGISTROS DE LOS PEDIDOS 
							DELETE 
							FROM VEN0004
							WHERE PEDNRO = V_NUM_PEDIDO
								AND CCOCOD =  CAST(IN_PUESTO(I) AS CHAR(3));							
							
						END;
					-- ==============================================
					-- SI LA CANTIDAD A CANCELAR ES MAYOS A LA CANTIDAD DE PEDIDOS POR ENTREGAR
					ELSIF (V_CANT_FALTAN < IN_CANTIDAD(I)) THEN 
						BEGIN
							OUT_CODIGO_MENSAJE := 1;
						END;
					-- ==============================================
					-- SI LA CANTIDAD A CANCELAR ES MENOR A LA CANTIDAD DE PEDIDOS POR ENTREGAR
					ELSIF (IN_CANTIDAD(I) <= V_CANT_FALTAN) THEN						
						BEGIN
							-- ==============================================
							-- ACTUALIZAR PEDIDO CON LA CANTIDAD QUITADA CON PRECIOS INCLUIDOS 							
							--CONSULTA LA CANTIDAD DEL PEDIDO RESTANDOLE LO QUE SE VA A CANCELAR
							SELECT PEDUNI - CAST(IN_CANTIDAD(I) AS NUMBER)
							INTO V_CANTIDAD
							FROM VEN0004
							WHERE CCOCOD = CAST(IN_PUESTO(I) AS NUMBER)
								AND PEDNRO = V_NUM_PEDIDO
								AND PEDPROCOD = CAST(IN_PLATOS_CANCELAR(I) AS CHAR(20));

							-- SI LA CANTIDAD FALTANTE ES CERO EN COMPARACION A LO TOTAL PEDIDO
							IF(V_CANTIDAD = 0) THEN 
								BEGIN
									-- SE ELIMINA EL PLATO DEL PEDIDO 
									--RAISE_APPLICATION_ERROR(-20001, 'CANTIDAD RESTANTE ='||V_CANTIDAD);
									DELETE FROM VEN0004
									WHERE CCOCOD = CAST(IN_PUESTO(I) AS NUMBER)
										AND PEDNRO = V_NUM_PEDIDO
										AND PEDPROCOD = CAST(IN_PLATOS_CANCELAR(I) AS CHAR(20));
								END;
							ELSE
								BEGIN									
									-- CONSULTA EL VALOR DEL PRODUCTO CON IVA INCLUIDO JUNTO CON LA CANTIDAD PEDIDA
									SELECT PEDVALIVA * V_CANTIDAD, PEDVAL
									INTO V_VALOR_ITEM_IVA, V_PRECIO_ITEM
									FROM VEN0004
									WHERE CCOCOD = CAST(IN_PUESTO(I) AS NUMBER)
										AND PEDNRO = V_NUM_PEDIDO
										AND PEDPROCOD = CAST(IN_PLATOS_CANCELAR(I) AS CHAR(20));
									--
									SELECT RFPORDTO
									INTO V_RFPORDTO
								    FROM VEN0001 A
								    INNER JOIN VEN0004 B
										ON A.VENEMPPAI = B.PEDPAIC
										AND A.VENEMPC = B.PEDEMPC
										AND A.PROCOD = B.PEDPROCOD 
								    WHERE A.PROCOD = CAST(IN_PLATOS_CANCELAR(I) AS CHAR(20))
								      	AND B.PEDNRO = V_NUM_PEDIDO;
								    --
								    IF(V_RFPORDTO > 0) THEN
										BEGIN
											V_VALDESC := (V_PRECIO_ITEM * V_CANTIDAD * V_RFPORDTO) / 100;
										END;
									ELSE
										BEGIN
											V_RFPORDTO := 0;
											V_VALDESC := 0;
										END;
									END IF;

									
									-- ==============================================
									-- SI LA CANTIDAD A CANCELAR MENOS LA CANTIDAD POR ENTREGAR DA CERO 
									IF((V_CANT_FALTAN - IN_CANTIDAD(I)) = 0) THEN 
										BEGIN
											V_ESTADO_PED := 'E';
										END;
									ELSE 
										BEGIN
											V_ESTADO_PED := 'N';
										END;
									END IF;
									-- ACTUALIZA EL PEDIDO 
									UPDATE VEN0004
									SET PEDUNI = V_CANTIDAD,
										PEDPORDC = V_RFPORDTO,
										PEDDCVAL = V_VALDESC,
										PEDVALTUN = V_CANTIDAD * V_VALOR_ITEM_IVA,
										PEDCHECK = V_CANT_FALTAN - IN_CANTIDAD(I),
										PEDSAL = V_ESTADO_PED
									WHERE CCOCOD = CAST(IN_PUESTO(I) AS NUMBER)
										AND PEDNRO = V_NUM_PEDIDO
										AND PEDPROCOD = CAST(IN_PLATOS_CANCELAR(I) AS CHAR(20));
								END;
							END IF;

						END;
					END IF;

				END LOOP;
			END;
		END IF;

	END SP_ACOMER_PEDIDOS_CANCEL;

-- =============================================
-- LOS DATOS DE LA FACTURA PARA PREVISUALIZARLA ANTES DE GENERARLA
	PROCEDURE SP_ACOMER_VISUALIZA_FAC
	(
		IN_CODIGO_MESA IN INV00018.MESCOD%TYPE,  -- CODIGO DE LA MESA DEL PEDIDO 	
		IN_PUESTOS_ARRAY IN TYPE_PEDIDOS_ARRAY,	-- PUESTOS QUE SE VAN A FACTURAR
		OUT_CURSOR_VISUALIZA OUT SYS_REFCURSOR,   -- CURSOR CON LOS DATOS DE LA CABECERA DE FACTURA
		OUT_FECHA OUT VARCHAR2
	)
	AS
	BEGIN
		-- SE REALIZA LA CONSULTA CON CADA UNO DE LOS DATOS INGRESADOS EN MESA
		FOR I IN IN_PUESTOS_ARRAY.FIRST..IN_PUESTOS_ARRAY.LAST
		LOOP
			INSERT INTO TT_VISUALIZA_FAC
				SELECT I CONSEC, B.PRODES NOMBRE, A.PEDUNI UNIDAD,A.PEDVAL*A.PEDUNI VALOR
				FROM VEN0004 A
				INNER JOIN VEN0001 B
					ON B.PROCOD = A.PEDPROCOD
				INNER JOIN VEN0104 C
					ON A.PEDNRO = C.PEDNRO 
				INNER JOIN INV00018 D
					ON D.MESCOD = IN_CODIGO_MESA
					AND C.PEDNUMDOC IN (D.MESNUMREQ,D.MESNUMREQ2,D.MESNUMREQ3,D.MESNUMREQ4)--AND C.PEDNUMDOC IN ('20150250','20150134')
					AND A.CCOCOD = CAST(IN_PUESTOS_ARRAY(I) AS CHAR(3))
				WHERE A.PEDSAL IN ('N','T','E');
	      COMMIT;
		END LOOP;



		OPEN OUT_CURSOR_VISUALIZA FOR
			SELECT TRIM(DESCRIPCION_PRODUCTO) PRODUCTO,
				SUM(UNIDADES_PRODUCTO) UNIDAD,
				SUM(VALOR_PRODUCTO) VALOR,
				SUM(VALOR_PRODUCTO)*(19/100) VALOR_IVA
			FROM TT_VISUALIZA_FAC
			GROUP BY DESCRIPCION_PRODUCTO;



		SELECT TO_CHAR(SYSDATE(),'DD')||'/'||TO_CHAR(SYSDATE(),'MM')||'/'||TO_CHAR(SYSDATE(), 'YYYY')
		INTO OUT_FECHA
		FROM DUAL;
			
	END SP_ACOMER_VISUALIZA_FAC;

-- =============================================
-- CONSULTA LAS MESAS QUE DEBEN ESTAR UNIDAS A ELLA
	PROCEDURE SP_ACOMER_MESA_PRINC_HIJOS
	(
		IN_CODIGO_MESA IN VEN0104.MESCOD%TYPE, -- CODIGO DE LA MESA QUE HA HECHO PEDIDO
		OUT_MESAS OUT VARCHAR2				   -- MESAS QUE ESTAN UNIDAS EN EL PEDIDO
	)
	AS
		V_MESA_PRINCIPAL UNIONMESA.MESCOD%TYPE;
		V_MESA_SECUNDARIA UNIONMESA.MESCODUNI%TYPE;
		V_CADENA_MESAS VARCHAR2(200);
		-- CONSULTA LAS MESAS QUE ESTAN UNIDAS 
		CURSOR CURSOR1 (CUR_MESA_PRINCIPAL NUMBER) IS 
			SELECT DISTINCT MESCODUNI
			FROM UNIONMESA
			WHERE MESCOD = CUR_MESA_PRINCIPAL;
	BEGIN
		-- CONSULTA CON EL CODIGO DE LA MESA CUAL ES LA PRINCIPAL 
		SELECT DISTINCT MESCOD
		INTO V_MESA_PRINCIPAL
		FROM UNIONMESA
		WHERE MESCOD = IN_CODIGO_MESA
			OR MESCODUNI = IN_CODIGO_MESA;

		-- ABRE EL CURSOR
		OPEN CURSOR1 (V_MESA_PRINCIPAL);
		-- RECORRE EL CURSOR
		LOOP
			FETCH CURSOR1 INTO V_MESA_SECUNDARIA;
			-- SALE DEL CICLO CUANDO NO ENCUENTRE NINGUN DATO  EN EL CURSOR
			EXIT WHEN CURSOR1%NOTFOUND;
			
			--LLENO CON LOS CODIGOS DE LAS MESAS QUE ESTAN UNIDAS \
			V_CADENA_MESAS := V_CADENA_MESAS || V_MESA_SECUNDARIA || '_*';		
		END LOOP;
		-- CIERRA EL CURSRO
		CLOSE CURSOR1;
		--QUITA EL ULTIMA *_
		V_CADENA_MESAS := SUBSTR(V_CADENA_MESAS, 0,LENGTH(V_CADENA_MESAS)-2);
		-- CONCATENA LOS CODIGOS DE LAS MESAS CON LA PRINCIPAL 
		V_CADENA_MESAS := TO_CHAR(V_MESA_PRINCIPAL) || '_*' || V_CADENA_MESAS;
		-- ASIGNA EL RESULTADO A LA VARIABLE DE SALIDA
		OUT_MESAS := V_CADENA_MESAS;

	END SP_ACOMER_MESA_PRINC_HIJOS;

-- =============================================
--  CARGA LAS MESAS EN LA PLAZA
	PROCEDURE SP_ACOMER_MESAS	
	(
		CURSOR_MESAS OUT SYS_REFCURSOR --CURSOR QUE TENDRA LOS DATOS DE LA MESA (EMP, IDENTIFICADOR, PUESTOS, COORDENADAS)
	)
	AS
	BEGIN
		-- EJECUTA LOS TIEMPOS DE DEMORA DE LOS PEDIDOS
		SP_ACOMER_TIEMPO_PEDIDO();

		-- CARGA AL CURSOR 
		OPEN CURSOR_MESAS FOR
			SELECT INV.MESCOD COD_MESA,
				CASE TRIM(INV.MESESTADO)
	                WHEN 'Ocupado' THEN
	                    '0'
	                ELSE '1'
			    END ESTADO,
			    --NVL(TRIM(INV.MESESTADO),'Activo') ESTADO,
			    DM.EMPCOD COD_EMPRESA,
			    DM.POSMES POSICION,
			    CASE DM.PUESTOS
					WHEN 0 THEN 4
					ELSE DM.PUESTOS
				END PUESTOS,
			    --NVL(DM.PUESTOS, 4) PUESTOS,
			    INV.MESHORAPED ATENCION,
			    CASE
                    WHEN GREATEST(TT.TIEMPO_CONTAINER1, TT.TIEMPO_CONTAINER2, TT.TIEMPO_CONTAINER3, TT.TIEMPO_CONTAINER4) = 0 THEN 
                        'SIN_RETRASO'
                    ELSE
                        FN_TIEMPO_TRASCURRIDO_PEDIDO(INV.MESCOD,INV.MESHORAPED, GREATEST(TT.TIEMPO_CONTAINER1, TT.TIEMPO_CONTAINER2, TT.TIEMPO_CONTAINER3, TT.TIEMPO_CONTAINER4)) 
                END TIEMPO
			    --FN_TIEMPO_TRASCURRIDO_PEDIDO(INV.MESCOD,INV.MESHORAPED, 
			    		--GREATEST(TT.TIEMPO_CONTAINER1, TT.TIEMPO_CONTAINER2, TT.TIEMPO_CONTAINER3, TT.TIEMPO_CONTAINER4)) TIEMPO
			FROM INV00018 INV
			INNER JOIN DETMESA DM
			    ON DM.MESCOD = INV.MESCOD
			INNER JOIN TT_TIME_MESA_CONTAINER TT
                ON TT.CODIGO_MESA = INV.MESCOD
			ORDER BY INV.MESCOD;			
	END SP_ACOMER_MESAS;

-- =============================================
-- LIBERAR LAS MESAS QUE SE ENCUENTREN UNIDAS ENTRE SI
	PROCEDURE SP_ACOMER_LIBERAR_MESA_UNIDA
	(
		IN_CODIGO_MESA IN VEN0104.MESCOD%TYPE 	-- CODIGO DE LA MESA DEL PEDIDO 	
	)
	AS
		V_MESA_PRINCIPAL UNIONMESA.MESCOD%TYPE; -- MESA PRINCIPAL
		V_CONTADOR_GLOBAL NUMBER := 0; -- CANTIDAD DE PUESTOS QUE FALTA POR FACTURAR
		V_CODIGO_PEDIDO TYPE_PEDIDOS_ARRAY; -- CODIGO DE LOS PEDIDOS QUE HAY EN MESA
		V_MESA_UNIDA NUMBER;
		-- CURSOR DE LAS MESAS UNIDAS A LA PRINCIPAL
		CURSOR CUR_UNIDAS IS 
			SELECT DISTINCT MESCODUNI
			FROM UNIONMESA
			WHERE MESCOD = IN_CODIGO_MESA
				OR MESCODUNI = IN_CODIGO_MESA;
		CV_MESA_UNIDA UNIONMESA.MESCODUNI%TYPE;	-- VARIABLE QUE RECIBE EL LOS DATOS RETORNADOS EN EL CURSOS	
	BEGIN
		-- SABER SI ES UNA MESA QUE ESTA UIDA A OTRA O ES SOLA
		SELECT COUNT(*)
		INTO V_MESA_UNIDA
		FROM UNIONMESA
		WHERE MESCOD = IN_CODIGO_MESA
		  	OR MESCODUNI = IN_CODIGO_MESA;

		-- SI ES UNA MESA UIDA A OTRA REALIZA LA ACCION
		IF(V_MESA_UNIDA > 0) THEN 
			-- CONSULTA CUAL ES LA MESA PRNCIPAL 
		    SELECT DISTINCT MESCOD
		    INTO V_MESA_PRINCIPAL
			FROM UNIONMESA
			WHERE MESCOD = IN_CODIGO_MESA
				OR MESCODUNI = IN_CODIGO_MESA;

			OPEN CUR_UNIDAS;
			-- OBTENER LOS DATOS FILA POR FILA 
			FETCH CUR_UNIDAS INTO CV_MESA_UNIDA;
			-- CICLO PARA LEER LOS DATOS DEVUELTOS EN EL CURSOR
			WHILE CUR_UNIDAS%FOUND 
			LOOP
				-- SI ES DISTINTO DE LA MESA QUE INGRESA
				IF(CV_MESA_UNIDA <> IN_CODIGO_MESA) THEN
					BEGIN
						SELECT 
							CASE NVL(MESNUMREQ, 'SIN_PEDIDO')
								WHEN 'SIN_PEDIDO' THEN 0
								ELSE 1
							END +
							CASE NVL(MESNUMREQ2, 'SIN_PEDIDO')
								WHEN 'SIN_PEDIDO' THEN 0
								ELSE 1
							END +
							CASE NVL(MESNUMREQ3, 'SIN_PEDIDO')
								WHEN 'SIN_PEDIDO' THEN 0
								ELSE 1
							END +
							CASE NVL(MESNUMREQ4, 'SIN_PEDIDO')
								WHEN 'SIN_PEDIDO' THEN 0
								ELSE 1
							END +
							V_CONTADOR_GLOBAL CANTIDAD_PEDIDO 
						INTO V_CONTADOR_GLOBAL
						FROM INV00018
						WHERE MESCOD = CV_MESA_UNIDA;
					END;
				END IF;

				-- OBTENER LOS DATOS FILA POR FILA 
				FETCH CUR_UNIDAS INTO CV_MESA_UNIDA;
			END LOOP;
			-- CIERRA EL CURSRO
			CLOSE CUR_UNIDAS;

			SELECT 
				CASE NVL(MESNUMREQ, 'SIN_PEDIDO')
					WHEN 'SIN_PEDIDO' THEN 0
					ELSE 1
				END +
				CASE NVL(MESNUMREQ2, 'SIN_PEDIDO')
					WHEN 'SIN_PEDIDO' THEN 0
					ELSE 1
				END +
				CASE NVL(MESNUMREQ3, 'SIN_PEDIDO')
					WHEN 'SIN_PEDIDO' THEN 0
					ELSE 1
				END +
				CASE NVL(MESNUMREQ4, 'SIN_PEDIDO')
					WHEN 'SIN_PEDIDO' THEN 0
					ELSE 1
				END +
				V_CONTADOR_GLOBAL CANTIDAD_PEDIDO 
			INTO V_CONTADOR_GLOBAL
			FROM INV00018
			WHERE MESCOD = V_MESA_PRINCIPAL;

			-- SI LA CANTIDAD DE PEDIDOS PENDIENTES EES MAYOR A CERO SE LIBERA LA MESA ACTUAL PERO SE DEJA OCUPADA PARA CONSERVAR LA UNIOIN
			IF(V_CONTADOR_GLOBAL > 0) THEN
				BEGIN
					UPDATE INV00018
					SET MESESTADO = 'Ocupado',					
						MESDOCREQ = 'PD',
						MESNUMREQ = '',
						MESNUMREQ2 = '',
						MESNUMREQ3 = '',
						MESNUMREQ4 = '',
						MESUSUREQ = '',
						MESHORAPED = TO_CHAR(SYSDATE,'HH24:MI:SS')
					WHERE MESCOD = IN_CODIGO_MESA;
				END;
			-- SI LA CANTIDAD DE PEDIDOS ES CERO SE LIBERAN TODAS LAS MESAS
			ELSIF(V_CONTADOR_GLOBAL = 0) THEN
				BEGIN
					OPEN CUR_UNIDAS;
					-- OBTENER LOS DATOS FILA POR FILA 
					FETCH CUR_UNIDAS INTO CV_MESA_UNIDA;
					-- CICLO PARA LEER LOS DATOS DEVUELTOS EN EL CURSOR
					WHILE CUR_UNIDAS%FOUND 
					LOOP				
						
						BEGIN
							UPDATE INV00018
							SET MESESTADO = 'Activo',
								MESDOCREQ = '',
								MESNUMREQ = '',
								MESNUMREQ2 = '',
								MESNUMREQ3 = '',
								MESNUMREQ4 = '',
								MESUSUREQ = '',
								MESHORAPED = ''
							WHERE MESCOD = CV_MESA_UNIDA;

							UPDATE DETMESA
							SET PUESTOS = 0
							WHERE MESCOD = CV_MESA_UNIDA;
						END;
						

						-- OBTENER LOS DATOS FILA POR FILA 
						FETCH CUR_UNIDAS INTO CV_MESA_UNIDA;
					END LOOP;
					-- CIERRA EL CURSRO
					CLOSE CUR_UNIDAS;

					-- LIBERA LA MESA PRINCIPAL
					UPDATE INV00018
					SET MESESTADO = 'Activo',
						MESDOCREQ = '',
						MESNUMREQ = '',
						MESNUMREQ2 = '',
						MESNUMREQ3 = '',
						MESNUMREQ4 = '',
						MESUSUREQ = '',
						MESHORAPED = ''
					WHERE MESCOD = V_MESA_PRINCIPAL;

					-- LIBERANDO LOS PUESTOS DE LA MESA
					UPDATE DETMESA
					SET PUESTOS = 0
					WHERE MESCOD = V_MESA_PRINCIPAL;

					-- SE ELIMNA LA UNION DE LA MESA }
					DELETE FROM UNIONMESA
					WHERE MESCOD = V_MESA_PRINCIPAL;
				END;
			END IF;
		END IF;
	END SP_ACOMER_LIBERAR_MESA_UNIDA;

-- =============================================
-- ACTUALIZA EL PEDIDO DE UN PUESTO ESPECIFICO
	PROCEDURE SP_ACOMER_PEDIDOS_ACT
	(
		IN_CODIGO_PRODUCTO IN VEN0001.PROCOD%TYPE, -- CODIGO DEL ITEM QUE SE ADICIONARA
		IN_CODIGO_PEDIDO IN VEN0104.PEDNRO%TYPE,   -- CODIGO DEL PEDIDO QUE YA TIENE EN LA MESA
		IN_CODIGO_PUESTO IN VEN0004.CCOCOD%TYPE,   -- PUESTO DESDE DONDE SE ESTA PIDIENDO
		IN_CANTIDAD IN VEN0004.PEDUNI%TYPE		   -- CANTIDD DEL PRODUCTO QUE SE ESTA PIDIENDO 
	)
	AS
		V_CANTIDAD VEN0004.PEDUNI%TYPE;   			-- CANTIDAD TOTAL CON LO PEDIDO Y LO QUE SE VA A PEDIR
		V_VALOR_ITEM_IVA VEN0004.PEDVALIVA%TYPE;	-- VALOR DEL ITEM CON IVA
		V_CODIGO_RESTAURANTE VEN0004.PEDEMPC%TYPE;	-- CODIGO DEL RESTAURANTE
		V_CODIGO_PAIS VEN0004.PEDPAIC%TYPE;			-- CODIGO DEL PAIS 
		V_VALDESC VEN0004.peddcval%TYPE;			-- peddcval
		V_RFPORDTO VEN0001.RFPORDTO%TYPE;			-- RFPORDTO 
		V_PRECIO_ITEM VEN0004.PEDVALIVA%TYPE;		-- VALOR DEL ITEM CON IVA
	BEGIN
	-- CONSULTA LA CANTDAD ACTUAL QUE HAY PEDIDO DEL 
		SELECT PEDUNI + IN_CANTIDAD
		INTO V_CANTIDAD
		FROM VEN0004
		WHERE CCOCOD = IN_CODIGO_PUESTO
			AND PEDNRO = IN_CODIGO_PEDIDO
			AND PEDPROCOD = IN_CODIGO_PRODUCTO;

		-- CONSULTAMOS EL VALOR DEL ITEM CON IVA INCLUIDO
		SELECT PEDVALIVA * V_CANTIDAD, PEDVALIVA
		INTO V_VALOR_ITEM_IVA, V_PRECIO_ITEM
		FROM VEN0004
		WHERE CCOCOD = IN_CODIGO_PUESTO
			AND PEDNRO = IN_CODIGO_PEDIDO
			AND PEDPROCOD = IN_CODIGO_PRODUCTO;

		--CONSULTA EL CODIGO DEL RESTAURANTE
		SELECT PEDEMPC, PEDPAIC
		INTO V_CODIGO_RESTAURANTE, V_CODIGO_PAIS 
		FROM VEN0004
		WHERE CCOCOD = IN_CODIGO_PUESTO
			AND PEDNRO = IN_CODIGO_PEDIDO
			AND PEDPROCOD = IN_CODIGO_PRODUCTO;

		--
		SELECT RFPORDTO
		INTO V_RFPORDTO
		FROM VEN0001
		WHERE VEN0001.VENEMPPAI = V_CODIGO_PAIS
			AND VEN0001.VENEMPC = V_CODIGO_RESTAURANTE
			AND VEN0001.PROCOD = IN_CODIGO_PRODUCTO;

		--
		IF(V_RFPORDTO > 0) THEN
			BEGIN
				V_VALDESC := (V_PRECIO_ITEM * V_CANTIDAD * V_RFPORDTO) / 100;
			END;
		ELSE
			BEGIN
				V_RFPORDTO := 0;
				V_VALDESC := 0;
			END;
		END IF;

	-- ==============================================
	-- ACTUALIZA EL DETALLE DEL PEDIDO 
		UPDATE VEN0004
		SET PEDUNI = V_CANTIDAD,
			PEDVALTUN = V_VALOR_ITEM_IVA,
			PEDPORDC = V_RFPORDTO,
			PEDDCVAL = V_VALDESC,
			PEDSAL = 'N',
			PEDCHECK = IN_CANTIDAD
		WHERE PEDPROCOD = IN_CODIGO_PRODUCTO
			AND PEDNRO = IN_CODIGO_PEDIDO
			AND CCOCOD = IN_CODIGO_PUESTO;
	END SP_ACOMER_PEDIDOS_ACT;

-- =============================================
-- INSERTA LA CABECERA DEL PEDIDO 
	PROCEDURE SP_ACOMER_PEDIDOS_CAB
	(
		IN_CODIGO_RESTAURANTE IN  GEN0006.EMPCOD%TYPE,	   -- RESTAURANTE AL CUAL SE LE HACE EL PEDIDO
		IN_CODIGO_DOCUMENTO_PEDIDO IN GEN0012.DOCCOD%TYPE, -- VDOCUMENTO DE PEDIDO PARA SABER EL NUMERO DE PEDIDO DEPENDIENDO EL RESTAURANTE 
		IN_CODIGO_MESERO IN SEG0001.USUID%TYPE,        	   -- CEDULA DEL MESERO QUE ESTA TOMANDO EL PEDIDO 
		IN_CODIGO_MESA_USADA IN INV00018.MESCOD%TYPE,	   -- CODIGO DE LA MESA
		OUT_NUMERO_PEDIDO OUT VEN0104.PEDNRO%TYPE		   -- CODIGO DEL PEDIDO
	)
	AS
		V_CODIGO_PAIS VEN0104.PEDPAIC%TYPE;  -- VARIABLE QUE CONTIENE EL CODIGO DEL PAIS 
		V_CODIGO_PEDIDO GEN0012.DOCNRO%TYPE; -- CODIGO CON EL CUAL QUEDA REGISTRADO LOS PEDIDOS DE UNA MESA
		V_FECHA_PEDIDO VEN0104.PEDFECH%TYPE; -- FEHCA QUE SE REALIZO EL PEDIDO
		V_USUARIO SEG0001.USUID%TYPE;		 -- IDENTIFCARDOR (USUARIO) DEL MESERO
		V_HORA_PEDIDO VEN0104.PEDHORA%TYPE;  -- HORA QUE SE TOMA EL PEDIDO 
		V_NUMERO_PEDIDO VEN0104.PEDNRO%TYPE; -- NUMERO DE PEDIDO

	BEGIN
	-- =============================================
	-- CONSULTA EL CODIGO DEL PAIS CON LA CEDULA DEL MESERO
		SELECT DISTINCT SEG0001.EMPPAIC 
		INTO V_CODIGO_PAIS
		FROM SEG0001 
		WHERE SEG0001.USUCED = IN_CODIGO_MESERO;

	-- =============================================
	-- CONSULTA EL NUMERO DE PEDIDO 
		SELECT TO_NUMBER(GEN0012.DOCNRO + 1)
		INTO V_CODIGO_PEDIDO
		FROM GEN0012
		WHERE GEN0012.DOCCOD = IN_CODIGO_DOCUMENTO_PEDIDO
			AND GEN0012.EMPPAIC = V_CODIGO_PAIS
			AND GEN0012.EMPCOD = IN_CODIGO_RESTAURANTE;	

	-- =============================================
	-- ACTUALIZO EL NUMERO DE DOCUMENTO
		UPDATE GEN0012
			SET  DOCNRO = V_CODIGO_PEDIDO
		WHERE GEN0012.DOCCOD = IN_CODIGO_DOCUMENTO_PEDIDO
			AND GEN0012.EMPPAIC = V_CODIGO_PAIS
			AND GEN0012.EMPCOD = IN_CODIGO_RESTAURANTE;	

	-- =============================================
	-- CONSULTA LA FECHA DEL SYSTEMA
		SELECT TO_DATE(SYSDATE, 'DD/MM/YYY')
		INTO V_FECHA_PEDIDO
		FROM DUAL;		

	-- =============================================
	-- CONSULTA EL USUARIO DEL MESERO
		SELECT DISTINCT SEG0001.USUID
		INTO V_USUARIO
		FROM SEG0001
		WHERE SEG0001.USUCED = '16743485'
	        AND ROWNUM = 1;

	-- =============================================
	-- CONSULTA LA HORA DE LA TOMA DEK PEDIDO 
		SELECT TO_CHAR(SYSDATE,'HH:MI:SS')
		INTO V_HORA_PEDIDO
		FROM DUAL;

	-- =============================================
	-- CONSULTA LA HORA DE LA TOMA DEK PEDIDO 
		SELECT NVL(MAX(PEDNRO),0) + 1
		INTO V_NUMERO_PEDIDO
		FROM VEN0104;

		OUT_NUMERO_PEDIDO := V_NUMERO_PEDIDO;

	-- =============================================
	-- INSERCION DE LOS DATOS DEL PEDIDO CABECERA
		INSERT INTO VEN0104(PEDPAIC, PEDEMPC, PEDCODDOC, PEDNUMDOC, 
			PEDFECH, PEDFECE, COTPAIC, COTEMPC, 
			PEDVENCOD, PEDFAC, PEDLC, PEDDEDT, 
			PEDFLE, PEDMODCOD, PEDORDCOM, PEDOTM, 
			PEDTDEOM, USUPAIC, USUEMPC, VENUSUARIO, 
			MESCOD, PEDHORA,PEDNRO)
		VALUES (V_CODIGO_PAIS, IN_CODIGO_RESTAURANTE, IN_CODIGO_DOCUMENTO_PEDIDO, V_CODIGO_PEDIDO,
			V_FECHA_PEDIDO, V_FECHA_PEDIDO, V_CODIGO_PAIS, IN_CODIGO_RESTAURANTE,
			IN_CODIGO_MESERO,'N','0','0',
			'0','PEDIDO','01','N',
			'0',V_CODIGO_PAIS,IN_CODIGO_RESTAURANTE,V_USUARIO,
			IN_CODIGO_MESA_USADA,V_HORA_PEDIDO, V_NUMERO_PEDIDO);

	END SP_ACOMER_PEDIDOS_CAB;

-- =============================================
-- INSERTA EL DETALLE DEL PEDIDO
	PROCEDURE SP_ACOMER_PEDIDOS_DET
	(
		IN_CODIGO_RESTAURANTE IN  GEN0006.EMPCOD%TYPE,	   -- RESTAURANTE AL CUAL SE LE HACE EL PEDIDO
		IN_CODIGO_DOCUMENTO_PEDIDO IN GEN0012.DOCCOD%TYPE, -- VDOCUMENTO DE PEDIDO PARA SABER EL NUMERO DE PEDIDO DEPENDIENDO EL RESTAURANTE 
		IN_CODIGO_PEDIDO IN VEN0004.PEDNRO%TYPE,		   -- NUMERO DE PEDIDO
		IN_CODIGO_ITME IN VEN0001.PROCOD%TYPE,			   -- CODIGO DEL ALIMENTO O ITEM QUE SE ESTA PIDIENDO 
		IN_CODIGO_TERMINO IN VEN0004.PEDBODL%TYPE,		   -- CODIGO DEL TERMINO DE LA COMIDAS
		IN_PUESTO_MESA IN VEN0004.CCOCOD%TYPE,			   -- PUESTO DE MESA DEL CUAL SE ESTA SOLICITANDO
		IN_CANTIDAD IN VEN0004.PEDUNI%TYPE,				   -- CANTIDAD DEL PRODUCTO
		IN_CODIGO_MESERO IN SEG0001.USUID%TYPE        	   -- CEDULA DEL MESERO QUE ESTA TOMANDO EL PEDIDO 
	)
	AS
		V_CODIGO_PAIS VEN0104.PEDPAIC%TYPE;  			-- VARIABLE QUE CONTIENE EL CODIGO DEL PAIS 
		V_CONTADOR_ITEMS_PEDIDO VEN0004.PEDLIN%TYPE;    -- CONTADOS DE LOS ITEM A PEDIR 
		V_PRECIO_ITEM VEN00012.PROPRE%TYPE;				-- PRECIO DEL ITEM SELECCIONADO
		V_VALOR_IVA  CNT0014.DEDPOR%TYPE;				-- VALOR DEL IVA PARA EL PRODUCTO
		V_IVA_ITEM VEN0004.PEDVALIVA%TYPE;				-- VALOR DEL PRODUCTO CON IVA
		V_TOTAL_ITEM VEN0004.PEDVALTUN%TYPE;			-- VALOR TOTAL CON LA CANTIDAD DEL ITEM 
		V_ALIAS_ITEM VEN0001.PROABR%TYPE;				-- ALIAS DEL PRODUCTO 
		V_RFPORDTO VEN0001.RFPORDTO%TYPE;				-- RFPORDTO 
		V_VALDESC VEN0004.peddcval%TYPE;				-- peddcval

	BEGIN
	-- =============================================
	-- CONSULTA EL CODIGO DEL PAIS CON LA CEDULA DEL MESERO
		SELECT DISTINCT SEG0001.EMPPAIC 
		INTO V_CODIGO_PAIS
		FROM SEG0001 
		WHERE SEG0001.USUCED = IN_CODIGO_MESERO;

	-- =============================================
	-- CONSULTA EL CODIGO DEL PAIS CON LA CEDULA DEL MESERO
		SELECT MAX(VEN0004.PEDLIN) + 1
		INTO V_CONTADOR_ITEMS_PEDIDO
		FROM VEN0004 
		WHERE VEN0004.PEDNRO = IN_CODIGO_PEDIDO;

		IF(V_CONTADOR_ITEMS_PEDIDO IS NULL) THEN
			BEGIN
				V_CONTADOR_ITEMS_PEDIDO := 1;
			END;
		END IF;

	-- =============================================
	-- CONSULTA EL PRECIO DEL ITEM SELECCIONADO
		SELECT VEN00012.PROPRE
		INTO V_PRECIO_ITEM
		FROM VEN00012
		WHERE VENEMPC = IN_CODIGO_RESTAURANTE
		    AND LIPCOD = '01'
		    AND PROCOD = IN_CODIGO_ITME;

	-- =============================================
	-- CONSULTA EL IVA PARA EL PRODUCTO
		SELECT CNT0014.DEDPOR
		INTO V_VALOR_IVA
		FROM VEN0001 
		LEFT JOIN CNT0014  
		    ON VEN0001.FDEDCOD = CNT0014.DEDCOD 
		    AND VEN0001.FDEDSC = CNT0014.DEDSUBCOD
		    AND VEN0001.FDEDANO = CNT0014.DEDANO 
		WHERE VEN0001.VENEMPPAI = V_CODIGO_PAIS 
		    AND VEN0001.VENEMPC = IN_CODIGO_RESTAURANTE 
		    AND VEN0001.PROCOD = IN_CODIGO_ITME;

	-- =============================================
	-- VALOR DEL PRODUCTO CON EL IVA
		V_IVA_ITEM := (((V_VALOR_IVA/100)*(V_PRECIO_ITEM)) + V_PRECIO_ITEM);

	-- =============================================
	-- SE CALCULA EL PRECIO TOTAL CONLA CANTIDAD PEDIDA DEL ITEM
		V_TOTAL_ITEM := IN_CANTIDAD * V_IVA_ITEM;

	-- =============================================
	-- CONSULTA EL ALIAS DEL ITEM O PRODUCTO
		SELECT PROABR, RFPORDTO
		INTO V_ALIAS_ITEM, V_RFPORDTO
		FROM VEN0001
		WHERE VEN0001.VENEMPPAI = V_CODIGO_PAIS
			AND VEN0001.VENEMPC = IN_CODIGO_RESTAURANTE
			AND VEN0001.PROCOD = IN_CODIGO_ITME;

		IF(V_RFPORDTO > 0) THEN
			BEGIN
				V_VALDESC := (V_PRECIO_ITEM * IN_CANTIDAD * V_RFPORDTO) / 100;
			END;
		ELSE
			BEGIN
				V_RFPORDTO := 0;
				V_VALDESC := 0;
			END;
		END IF;

	--- =============================================
	-- INSERTAR DETALLE DE LOS PEDIDOS
		INSERT INTO VEN0004(PEDPAIC, PEDEMPC, PEDCODDOC,PEDNRO,
			PEDLIN, PEDPROCOD, PEPC, PEC,
			CCOCOD, PEDUNI, PEDVAL, PEDVALCPI, 
			PEDPORIVA, PEDVALIVA, PEDVALTUN, PEDSUCDET,
			PEDALIAS, PEDPORDC, PEDDCVAL, PEDSAL,
			PEDBODL, PEDCHECK)
		VALUES(V_CODIGO_PAIS, IN_CODIGO_RESTAURANTE, IN_CODIGO_DOCUMENTO_PEDIDO, IN_CODIGO_PEDIDO,
			V_CONTADOR_ITEMS_PEDIDO, IN_CODIGO_ITME, V_CODIGO_PAIS, IN_CODIGO_RESTAURANTE,
			IN_PUESTO_MESA, IN_CANTIDAD, V_PRECIO_ITEM, 0,
			V_VALOR_IVA, V_IVA_ITEM, V_TOTAL_ITEM, '01',
			V_ALIAS_ITEM, V_RFPORDTO, V_VALDESC, 'N',
			IN_CODIGO_TERMINO, IN_CANTIDAD);

	END SP_ACOMER_PEDIDOS_DET;

-- =============================================
-- CALCULO DE LOS TIEMPOS DE LOS PEDIDOS
	PROCEDURE SP_ACOMER_TIEMPO_PEDIDO
	 /*(
	 	OUT_CURSOR_TIEMPOS OUT SYS_REFCURSOR	-- CURSOR CON LOS TIEMPOS DE CADA MESA
	 )*/
	 AS
	 	-- CODIGO DE TODAS LAS MESAS QUE ESTAN DISPONIBLES EN PLAZA
	 	DATACURSOR NUMBER; -- DATOS QUE TRAIGA EL CURSOR
	 	CURSOR CURSOR1 IS	-- CURSOR QUE TRAE TODOS LOS CODIGOS DE LAS MESAS
	 		SELECT MESCOD 
	 		FROM INV00018;

	 	V_CANTIDAD_PEDIDO NUMBER;	-- CANTIDAD DE PEDIDO QUE HAY EN UNA MESA POR RESTAURANTE
	 	V_CODIGO_CONTAINER PKG_ACOMER_PROCEDURES.TYPE_PEDIDOS_ARRAY; -- ARRAY CON LOS CODIGOS DE LOS CONTAINERS
	 	V_CAPACIDAD_CONTAINER PKG_ACOMER_PROCEDURES.TYPE_CAPACIDAD_CONTAINER; -- ARRRAY DE LA CAPACIDAD DE CADA CONTAINER 	
	 	V_TIEMPO_MAX NUMBER; -- TIEMPO MAXIMO DE UN PLATO DE LA MESA
	 	V_CONSECUTIVO NUMBER; -- CONSECUTIVO DE LA TABLA PEDIDOS  	
	 	V_IDENTIFICADOR_TIMEACU NUMBER;	
	 BEGIN 	
	 	-- LLENA EL ARRAY  CON LOS CODIGOS RESPECTIVOS
	 	V_CODIGO_CONTAINER(1) := PKG_ACOMER_PROCEDURES.PKG_CONTAINER1;
	 	V_CODIGO_CONTAINER(2) := PKG_ACOMER_PROCEDURES.PKG_CONTAINER2;
	 	V_CODIGO_CONTAINER(3) := PKG_ACOMER_PROCEDURES.PKG_CONTAINER3;
	 	V_CODIGO_CONTAINER(4) := PKG_ACOMER_PROCEDURES.PKG_CONTAINER4;
	 	-- LLENA EL ARAY CON LAS CAPACIDADE CORRESPONDIENTES
	 	V_CAPACIDAD_CONTAINER(PKG_ACOMER_PROCEDURES.PKG_CONTAINER1) := PKG_ACOMER_PROCEDURES.PKG_CAPACIDAD_CONTAINER1;
	 	V_CAPACIDAD_CONTAINER(PKG_ACOMER_PROCEDURES.PKG_CONTAINER2) := PKG_ACOMER_PROCEDURES.PKG_CAPACIDAD_CONTAINER2;
	 	V_CAPACIDAD_CONTAINER(PKG_ACOMER_PROCEDURES.PKG_CONTAINER3) := PKG_ACOMER_PROCEDURES.PKG_CAPACIDAD_CONTAINER3;
	 	V_CAPACIDAD_CONTAINER(PKG_ACOMER_PROCEDURES.PKG_CONTAINER4) := PKG_ACOMER_PROCEDURES.PKG_CAPACIDAD_CONTAINER4;

	 	-- LLENA LA TABLA CON LAS MESAS DISPONIBLES DE LA PLAZA
	 	OPEN CURSOR1;
	 	FETCH CURSOR1 INTO DATACURSOR;
	 	LOOP
	 		-- CUANDO NO ENCUENTRE DATOS EN CURSOR SALE
	 		EXIT WHEN CURSOR1%NOTFOUND;

	 		-- INSERTA LOS VALORES CORRESPONDIENTES
	 		INSERT INTO TT_TIME_MESA_CONTAINER(
	 			CODIGO_MESA)
	 		VALUES(
	 			DATACURSOR);

	 		FETCH CURSOR1 INTO DATACURSOR;
	 	END LOOP;
	 	CLOSE CURSOR1;

	 	-- CALCULAN LOS TIEMPOS DE CADA MESA EN CADA CONTAINER 
		FOR I IN V_CODIGO_CONTAINER.FIRST..V_CODIGO_CONTAINER.LAST
		LOOP
			-- CONSECUTIVO SE REINCIA CUANDO CAMBIA DE EMPRESA			
			V_CONSECUTIVO := 0;

	 		DECLARE 			
	 			-- PEDIDOS QUE HAY PARA CADA RESTAURANTE
	 			DATACURSOR21 VEN0001.PRODES%TYPE;   -- NOMBRE DEL PLATO
	 			DATACURSOR22 VEN0104.MESCOD%TYPE;   -- CODIGO DE LA MESA
	 			DATACURSOR23 VEN0104.PEDFECE%TYPE;  -- FECHA DEL PEDIDO 
	 			DATACURSOR24 VEN0104.PEDHORA%TYPE;	-- HORA DEL PEDIDO
	 			DATACURSOR25 VEN0004.PEDCHECK%TYPE;	-- CANTIDAD
	 			DATACURSOR26 VEN0104.PEDEMPC%TYPE;	-- EMPRESA
	 			DATACURSOR27 VEN0001.STMARCAS%TYPE;	-- TIEMPO DE DEMORA

	 			CURSOR CURSOR2 (IN_CURSOR CHAR)IS
	 				SELECT PLATO, MESA,
					    FECHA, HORA,	
					    CANTIDAD, EMPRESA,
					    TIEMPO
					FROM(					
					        SELECT PRODES PLATO, MESCOD MESA,
					            PEDFECE FECHA, PEDHORA HORA,
					            SUM(PEDCHECK) CANTIDAD, 			
					            PEDEMPC EMPRESA, STMARCAS TIEMPO
					        FROM(
					                SELECT DISTINCT PRODES, MESCOD,
					                    PEDFECE, PEDHORA,
					                    PEDCHECK, CCOCOD,
					                    PEDEMPC, STMARCAS
					                FROM(
					                        SELECT D.PRODES, B.MESCOD,
					                            B.PEDFECE, B.PEDHORA,
					                            A.PEDCHECK, A.CCOCOD,
					                            A.PEDEMPC, D.STMARCAS
					                        FROM VEN0004 A
					                        INNER JOIN VEN0104 B
					                            ON A.PEDNRO = B.PEDNRO
					                            AND B.PEDEMPC = IN_CURSOR
					                        INNER JOIN INV00018 C
					                            ON C.MESNUMREQ = B.PEDNUMDOC  		
					                            OR C.MESNUMREQ2 = B.PEDNUMDOC  		
					                            OR C.MESNUMREQ3 = B.PEDNUMDOC  		
					                            OR C.MESNUMREQ4 = B.PEDNUMDOC  		
					                        INNER JOIN VEN0001 D
					                            ON D.PROCOD = A.PEDPROCOD
					                        INNER JOIN INV0013 E
					                            ON E.CATECOD = D.VENCATCOD
					                        WHERE A.PEDSAL = 'N'
					                        ORDER BY B.PEDFECE, B.PEDHORA, B.MESCOD
					                    )
					            )				
					        GROUP BY PRODES, MESCOD,
					            PEDFECE, PEDHORA,
					            PEDEMPC, STMARCAS
					        ORDER BY PEDFECE, PEDHORA, MESCOD					
					    )
					ORDER BY FECHA, HORA, MESA;
	 		BEGIN

	 			OPEN CURSOR2(V_CODIGO_CONTAINER(I));
	 			FETCH CURSOR2 INTO DATACURSOR21, DATACURSOR22, DATACURSOR23, DATACURSOR24, DATACURSOR25, DATACURSOR26, DATACURSOR27;
	 			LOOP
	 				EXIT WHEN CURSOR2%NOTFOUND;	 				

	 				FOR J IN 1..DATACURSOR25
	 				LOOP	 
	 					-- INCREMENTA EN UNO EL CONSECUTIVO
	 					V_CONSECUTIVO := V_CONSECUTIVO + 1;					
	 					-- SE INSERTA LAS N VECES QUE SE PIDIO EL PLATO PARA ARAMAR LA COLA DEL PEDIDO
	 					INSERT INTO TT_PEDIDOS_TIEMPOS(
	 						CONSECUTIVO, PLATO, 
	 						MESA, FECHA, 
	 						HORA, EMPRESA, 
	 						TIEMPO)
	 					VALUES (
	 						V_CONSECUTIVO, DATACURSOR21, 
	 						DATACURSOR22, DATACURSOR23, 
	 						DATACURSOR24, DATACURSOR26, 
	 						DATACURSOR27);                    
	 				END LOOP;

	 				FETCH CURSOR2 INTO DATACURSOR21, DATACURSOR22, DATACURSOR23, DATACURSOR24, DATACURSOR25, DATACURSOR26, DATACURSOR27;

	 			END LOOP;
	 			CLOSE CURSOR2;

	 		END;
		END LOOP;

		FOR I IN V_CODIGO_CONTAINER.FIRST..V_CODIGO_CONTAINER.LAST
		LOOP        
			DECLARE			
				-- VARIABLES LOGICAS
				V_TIEMPO_MENOR NUMBER := 60; 
				V_CANTIDAD_CEROS NUMBER := 0; -- CANTIDAD DE PEDIDOS TERMINADOS EN SERVIDORES
				V_CANTIDAD_COLA NUMBER := 0;  -- CANTIDAD DE PEDIDO EN COLA 	
	            V_TIEMPO_TRANS NUMBER := 0;
				-- ARRAY DE LOS SERVIDORES
				CONSECUTIVO_ARRAY_SERVIDOR NUMBER := 0; 
				ARRAY_SERVIDORES_CONSECUTIVO PKG_ACOMER_PROCEDURES.TYPE_PEDIDOS_ARRAY;
				ARRAY_SERVIDORES_TIEMPO PKG_ACOMER_PROCEDURES.TYPE_PEDIDOS_ARRAY;
				ARRAY_SERVIDORES_EMPRESA PKG_ACOMER_PROCEDURES.TYPE_PEDIDOS_ARRAY;
				-- ARRAY DE LAS COLAS
				CONSECUTIVO_ARRAY_COLAS NUMBER := 0; 
				ARRAY_COLAS_CONSECUTIVO PKG_ACOMER_PROCEDURES.TYPE_PEDIDOS_ARRAY;			
				ARRAY_COLAS_TIEMPO  PKG_ACOMER_PROCEDURES.TYPE_PEDIDOS_ARRAY;
				ARRAY_COLAS_EMPRESA PKG_ACOMER_PROCEDURES.TYPE_PEDIDOS_ARRAY;
				-- ARRAY DE LAS COLAS
				CONSECUTIVO_ARRAY_CEROS NUMBER := 0; 
				ARRAY_COLAS_CEROS_CON PKG_ACOMER_PROCEDURES.TYPE_PEDIDOS_ARRAY;		
				ARRAY_COLAS_CEROS_POS PKG_ACOMER_PROCEDURES.TYPE_PEDIDOS_ARRAY;	
				-- ARRAY DE LAS COLAS QUE PASAN A LOS SERVIDORES
				CONSECUTIVO_ARRAY_TOSERV NUMBER := 0;
				ARRAY_TO_SERVIDORES PKG_ACOMER_PROCEDURES.TYPE_PEDIDOS_ARRAY;
				-- CURSOR DE LOS PEDIDOS 
				DATACURSOR31 NUMBER; 		-- CARGA DE DATOS QUE TRAE EL CURSOR CONSECUTIVO			
				DATACURSOR32 NUMBER; 		-- CARGA DE DATOS QUE TRAE EL CURSOR TIEMPO 			
				CURSOR CURSOR3 (IN_CURSOR31 CHAR, IN_CURSOR32 NUMBER, IN_CURSOR33 NUMBER) IS
					SELECT CONSECUTIVO, TIEMPO 
					FROM TT_PEDIDOS_TIEMPOS
					WHERE CONSECUTIVO BETWEEN IN_CURSOR32 AND IN_CURSOR33
						AND EMPRESA = IN_CURSOR31;		

			BEGIN
				-- LLENAR EL ARRAY DE LOS SERVIDORES
				OPEN CURSOR3(V_CODIGO_CONTAINER(I), 1, V_CAPACIDAD_CONTAINER(V_CODIGO_CONTAINER(I)));
				FETCH CURSOR3 INTO DATACURSOR31, DATACURSOR32;
				LOOP
					EXIT WHEN CURSOR3%NOTFOUND;
					-- AUMENTO EL CONSECUTIVO EN 1
					CONSECUTIVO_ARRAY_SERVIDOR := CONSECUTIVO_ARRAY_SERVIDOR + 1;
					-- LLENA EL ARRAY CON  EL TIEMPO DE CADA PLATO Y SU CONSECUTIVO
					ARRAY_SERVIDORES_CONSECUTIVO(CONSECUTIVO_ARRAY_SERVIDOR) := DATACURSOR31;
					ARRAY_SERVIDORES_TIEMPO(CONSECUTIVO_ARRAY_SERVIDOR) := DATACURSOR32;				
					ARRAY_SERVIDORES_EMPRESA(CONSECUTIVO_ARRAY_SERVIDOR) := V_CODIGO_CONTAINER(I);                
					-- 
					UPDATE TT_PEDIDOS_TIEMPOS
					SET TIEMPOACUMU = DATACURSOR32
					WHERE CONSECUTIVO = DATACURSOR31
						AND EMPRESA = CAST(V_CODIGO_CONTAINER(I) AS CHAR(13));

					FETCH CURSOR3 INTO DATACURSOR31, DATACURSOR32;
				END LOOP;
				CLOSE CURSOR3;

				-- CANTIDAD DE PEDIDOS POR CONTAINER
				SELECT COUNT(*)
				INTO V_CANTIDAD_PEDIDO
				FROM TT_PEDIDOS_TIEMPOS
				WHERE EMPRESA = CAST(V_CODIGO_CONTAINER(I) AS CHAR(13));
				-- LLENAR EL ARAY DE LA COLA 	
				OPEN CURSOR3(V_CODIGO_CONTAINER(I), V_CAPACIDAD_CONTAINER(V_CODIGO_CONTAINER(I))+1, V_CANTIDAD_PEDIDO);
				FETCH CURSOR3 INTO DATACURSOR31, DATACURSOR32;
				LOOP
					EXIT WHEN CURSOR3%NOTFOUND;
					-- AUMENTO EL CONSECUTIVO EN 1
					CONSECUTIVO_ARRAY_COLAS := CONSECUTIVO_ARRAY_COLAS + 1;
					-- LLENA EL ARRAY CON  EL TIEMPO DE CADA PLATO Y SU CONSECUTIVO
					ARRAY_COLAS_CONSECUTIVO(CONSECUTIVO_ARRAY_COLAS) := DATACURSOR31;
					ARRAY_COLAS_TIEMPO(CONSECUTIVO_ARRAY_COLAS) := DATACURSOR32;
					ARRAY_COLAS_EMPRESA(CONSECUTIVO_ARRAY_COLAS) := V_CODIGO_CONTAINER(I);
	               
					-- 
					FETCH CURSOR3 INTO DATACURSOR31, DATACURSOR32;
				END LOOP;
				CLOSE CURSOR3;

				-- CICLO PARA CALCULO DE TIEMPOS EN COLA
				LOOP                
					CONSECUTIVO_ARRAY_TOSERV := 0;
	                V_TIEMPO_MENOR := 60;
	                V_CANTIDAD_CEROS := 0;

					IF(ARRAY_SERVIDORES_TIEMPO.COUNT <> 0) THEN 
						-- CICLO PARA CALCULAR LOS TIEMPOS DE CADA PLATO 
						FOR J IN ARRAY_SERVIDORES_TIEMPO.FIRST..ARRAY_SERVIDORES_TIEMPO.LAST
						LOOP

							-- IDENTIFICAR EL MENOR DE LOS SERVIDORES
							IF(ARRAY_SERVIDORES_TIEMPO(J) < V_TIEMPO_MENOR) THEN
								V_TIEMPO_MENOR := ARRAY_SERVIDORES_TIEMPO(J);
							END IF;

						END LOOP;
	                    
	                    V_TIEMPO_TRANS := V_TIEMPO_TRANS + V_TIEMPO_MENOR;

						-- CICLO RESTAR EL MENOR TIEMPO A TODOS 
						FOR J IN ARRAY_SERVIDORES_TIEMPO.FIRST..ARRAY_SERVIDORES_TIEMPO.LAST
						LOOP
							-- IDENTIFICAR EL MENOR DE LOS SERVIDORES
							ARRAY_SERVIDORES_TIEMPO(J) := ARRAY_SERVIDORES_TIEMPO(J) - V_TIEMPO_MENOR;

						END LOOP;

						-- CONTAR TIEMPOS YA TERMINADOS
						FOR J IN ARRAY_SERVIDORES_TIEMPO.FIRST..ARRAY_SERVIDORES_TIEMPO.LAST
						LOOP
							-- IDENTIFICAR EL MENOR DE LOS SERVIDORES
							IF(ARRAY_SERVIDORES_TIEMPO(J) = 0) THEN 
								V_CANTIDAD_CEROS := V_CANTIDAD_CEROS + 1;
								CONSECUTIVO_ARRAY_CEROS := CONSECUTIVO_ARRAY_CEROS + 1;
								ARRAY_COLAS_CEROS_CON(CONSECUTIVO_ARRAY_CEROS) := ARRAY_SERVIDORES_CONSECUTIVO(J);
								ARRAY_COLAS_CEROS_POS(CONSECUTIVO_ARRAY_CEROS) := J;
							END IF;
						END LOOP;


						-- CANTIDAD DE PEDIDOS EN COLA 
						IF(ARRAY_COLAS_TIEMPO.COUNT <> 0) THEN
							V_CANTIDAD_COLA := ARRAY_COLAS_TIEMPO.COUNT;
						ELSE 
							V_CANTIDAD_COLA := 0;
						END IF;
	                    
						-- SI ES NEGATIVO HAY MAS ESPACIO QUE COLAS
						IF((V_CANTIDAD_COLA - V_CANTIDAD_CEROS) < 0) THEN 
							FOR J IN 1..V_CANTIDAD_COLA
							LOOP
								-- 									
								CONSECUTIVO_ARRAY_TOSERV := CONSECUTIVO_ARRAY_TOSERV + 1;
								ARRAY_TO_SERVIDORES(CONSECUTIVO_ARRAY_TOSERV) := J;
								--
								ARRAY_SERVIDORES_CONSECUTIVO(ARRAY_COLAS_CEROS_POS(J)) := ARRAY_COLAS_CONSECUTIVO(J);
								ARRAY_SERVIDORES_TIEMPO(ARRAY_COLAS_CEROS_POS(J)) 	   := ARRAY_COLAS_TIEMPO(J);
								ARRAY_SERVIDORES_EMPRESA(ARRAY_COLAS_CEROS_POS(J)) 	   := ARRAY_COLAS_EMPRESA(J);                           

							END LOOP;
						-- HAY MAS COLA QUE ESPACIO ENSERVIDORES
						ELSIF((V_CANTIDAD_COLA - V_CANTIDAD_CEROS) > 0) THEN 
							FOR J IN 1..V_CANTIDAD_CEROS
							LOOP
								-- 									
								CONSECUTIVO_ARRAY_TOSERV := CONSECUTIVO_ARRAY_TOSERV + 1;
								ARRAY_TO_SERVIDORES(CONSECUTIVO_ARRAY_TOSERV) := J;
								--
								ARRAY_SERVIDORES_CONSECUTIVO(ARRAY_COLAS_CEROS_POS(J)) := ARRAY_COLAS_CONSECUTIVO(J);
								ARRAY_SERVIDORES_TIEMPO(ARRAY_COLAS_CEROS_POS(J)) 	   := ARRAY_COLAS_TIEMPO(J);
								ARRAY_SERVIDORES_EMPRESA(ARRAY_COLAS_CEROS_POS(J)) 	   := ARRAY_COLAS_EMPRESA(J);                            

							END LOOP;
						-- LA CANTIDAD EN SERVIDORES ES IGUAL A LA COLA
						ELSE
							FOR J IN 1..V_CANTIDAD_CEROS
							LOOP
								-- 									
								CONSECUTIVO_ARRAY_TOSERV := CONSECUTIVO_ARRAY_TOSERV + 1;
								ARRAY_TO_SERVIDORES(CONSECUTIVO_ARRAY_TOSERV) := J;
								--
								ARRAY_SERVIDORES_CONSECUTIVO(ARRAY_COLAS_CEROS_POS(J)) := ARRAY_COLAS_CONSECUTIVO(J);
								ARRAY_SERVIDORES_TIEMPO(ARRAY_COLAS_CEROS_POS(J)) 	   := ARRAY_COLAS_TIEMPO(J);
								ARRAY_SERVIDORES_EMPRESA(ARRAY_COLAS_CEROS_POS(J)) 	   := ARRAY_COLAS_EMPRESA(J);
	                            
							END LOOP;
						END IF;

						-- ACOMODAR NUEVAMENTE LAS COLAS
						DECLARE
							--
							V_CONTADOR_POSCION NUMBER := 0;
							V_CONSECUTIVO_NUEVO NUMBER := 0;
							--
							COPY_ARRAY_COLAS_CONSECUTIVO PKG_ACOMER_PROCEDURES.TYPE_PEDIDOS_ARRAY := ARRAY_COLAS_CONSECUTIVO;
							COPY_ARRAY_COLAS_TIEMPO PKG_ACOMER_PROCEDURES.TYPE_PEDIDOS_ARRAY := ARRAY_COLAS_TIEMPO;
							COPY_ARRAY_COLAS_EMPRESA PKG_ACOMER_PROCEDURES.TYPE_PEDIDOS_ARRAY := ARRAY_COLAS_EMPRESA;
						BEGIN
							-- SE ELIMINAN LOS DATOS DE LAS COLAS
							ARRAY_COLAS_CONSECUTIVO.DELETE();
							ARRAY_COLAS_TIEMPO.DELETE();
							ARRAY_COLAS_EMPRESA.DELETE();
							-- SE REACOMODAN LAS COLAS
							IF(V_CANTIDAD_COLA > ARRAY_TO_SERVIDORES.COUNT) THEN
								FOR J IN COPY_ARRAY_COLAS_CONSECUTIVO.FIRST..COPY_ARRAY_COLAS_CONSECUTIVO.LAST
								LOOP
									--
									FOR K IN ARRAY_TO_SERVIDORES.FIRST..ARRAY_TO_SERVIDORES.LAST
									LOOP
										-- SI LA POSICION ES LA MISMA NO SE AGREGA
										IF(J = ARRAY_TO_SERVIDORES(K)) THEN
											V_CONTADOR_POSCION := V_CONTADOR_POSCION + 1;
										END IF;																
									END LOOP;

									IF(V_CONTADOR_POSCION = 0) THEN 
										-- AUMENTA UNO EN LA POSICION
										V_CONSECUTIVO_NUEVO := V_CONSECUTIVO_NUEVO + 1;
										--LLENA LA NUEVA COLA 
										ARRAY_COLAS_CONSECUTIVO(V_CONSECUTIVO_NUEVO) := COPY_ARRAY_COLAS_CONSECUTIVO(J);
										ARRAY_COLAS_TIEMPO(V_CONSECUTIVO_NUEVO) := COPY_ARRAY_COLAS_TIEMPO(J);
										ARRAY_COLAS_EMPRESA(V_CONSECUTIVO_NUEVO) := COPY_ARRAY_COLAS_EMPRESA(J);
									END IF;

									V_CONTADOR_POSCION := 0;
								END LOOP;
							END IF;
						END;

						--ACTUALIZAN LOS TIEMPOS
						IF(ARRAY_TO_SERVIDORES.COUNT > 0) THEN
							FOR J IN ARRAY_SERVIDORES_CONSECUTIVO.FIRST..ARRAY_SERVIDORES_CONSECUTIVO.LAST
							LOOP
								-- CONSULTA EL ESTADO DEL TIEMPO ACUMULADO DEL PLATO 
								SELECT 
									CASE
										WHEN TIEMPOACUMU = 0 THEN 
											0
										ELSE
											1
									END
								INTO V_IDENTIFICADOR_TIMEACU
								FROM TT_PEDIDOS_TIEMPOS
								WHERE CONSECUTIVO = CAST(ARRAY_SERVIDORES_CONSECUTIVO(J) AS NUMBER)
									AND EMPRESA = CAST(ARRAY_SERVIDORES_EMPRESA(J) AS CHAR(13));
								
								-- SI ES CERO SE ACTUALIZA EL TIEMPO ACUMULADO PARA EL PLATO INDICADO								
								IF(V_IDENTIFICADOR_TIMEACU = 0) THEN                                 
									UPDATE TT_PEDIDOS_TIEMPOS
									SET TIEMPOACUMU = CAST(ARRAY_SERVIDORES_TIEMPO(J) AS NUMBER) + V_TIEMPO_TRANS
									WHERE CONSECUTIVO = CAST(ARRAY_SERVIDORES_CONSECUTIVO(J) AS NUMBER)
										AND EMPRESA = CAST(ARRAY_SERVIDORES_EMPRESA(J) AS CHAR(13));
								END IF;


							END LOOP;

						END IF;

					END IF;

					-- CUANDO NO HAY MAS PEDIDOS EN COLA SALE DE CICLO
					IF(ARRAY_COLAS_TIEMPO.COUNT = 0) THEN 
						EXIT;
					END IF;

				END LOOP;
			END;
		END LOOP;

		-- ACTUALIZA EL TIEMPO DE CADA MESA EN CADA CONTAINER
		DECLARE
			V_TIEMPO_MESA_CONTAINER NUMBER; -- TIEMPO MAXIMO DE LA MESA EN EL CONTAINER
			DATACURSOR41 NUMBER; 			-- NUMERO DE LA MESA
			CURSOR CURSOR4 IS 
				SELECT CODIGO_MESA
				FROM TT_TIME_MESA_CONTAINER;
		BEGIN
			FOR I IN V_CODIGO_CONTAINER.FIRST..V_CODIGO_CONTAINER.LAST
			LOOP

				OPEN CURSOR4;
				FETCH CURSOR4 INTO DATACURSOR41;
				LOOP
					EXIT WHEN CURSOR4%NOTFOUND;
					-- CONSULTA EL TIEMPO MAYO DE LA MESA
					SELECT NVL(MAX(TIEMPOACUMU),0)
					INTO V_TIEMPO_MESA_CONTAINER
					FROM TT_PEDIDOS_TIEMPOS
					WHERE MESA = DATACURSOR41
						AND EMPRESA = CAST(V_CODIGO_CONTAINER(I) AS CHAR(13));

					CASE V_CODIGO_CONTAINER(I)
						WHEN PKG_ACOMER_PROCEDURES.PKG_CONTAINER1 THEN
							UPDATE TT_TIME_MESA_CONTAINER
							SET TIEMPO_CONTAINER1 = V_TIEMPO_MESA_CONTAINER
							WHERE CODIGO_MESA =DATACURSOR41;
						WHEN PKG_ACOMER_PROCEDURES.PKG_CONTAINER2 THEN
							UPDATE TT_TIME_MESA_CONTAINER
							SET TIEMPO_CONTAINER2 = V_TIEMPO_MESA_CONTAINER
							WHERE CODIGO_MESA = DATACURSOR41;
						WHEN PKG_ACOMER_PROCEDURES.PKG_CONTAINER3 THEN
							UPDATE TT_TIME_MESA_CONTAINER
							SET TIEMPO_CONTAINER3 = V_TIEMPO_MESA_CONTAINER
							WHERE CODIGO_MESA = DATACURSOR41;
						WHEN PKG_ACOMER_PROCEDURES.PKG_CONTAINER4 THEN
							UPDATE TT_TIME_MESA_CONTAINER
							SET TIEMPO_CONTAINER4 = V_TIEMPO_MESA_CONTAINER
							WHERE CODIGO_MESA = DATACURSOR41;
					END CASE;

					FETCH CURSOR4 INTO DATACURSOR41;
				END LOOP;
				CLOSE CURSOR4;

			END LOOP;
		END;

	 	-- CONFIRMACION DE LOS CAMBIOS Y SE CARGAN LOS DATOS EN EL CURSOR 
	 	COMMIT;

	 	/*OPEN OUT_CURSOR_TIEMPOS FOR
	 		SELECT CODIGO_MESA MESA,
	 			GREATEST(TIEMPO_CONTAINER1, TIEMPO_CONTAINER2, TIEMPO_CONTAINER3, TIEMPO_CONTAINER4) TIEMPO
	 		FROM TT_TIME_MESA_CONTAINER;*/
	END SP_ACOMER_TIEMPO_PEDIDO;

-- =============================================
-- FUNCION PARA CALCULAR EL TIEMPO TRASCURRIDO DEL PEDIDO
	FUNCTION FN_TIEMPO_TRASCURRIDO_PEDIDO	 
	(
		IN_MESA NUMBER,			  -- CODIGO DE LA MESA
		IN_HORA_PEDIDO VARCHAR2,  -- HORA EN LA QUE EL PEDIDO FUE REALIZADO
	 	IN_TIEMPO_DEMORA NUMBER   -- NUMERO DE MINUTOS QUE DEMORA EL PEDIDO EN SER ENTREGADO A LA MESA
	)
	RETURN VARCHAR2
	AS
		V_FECHA_PEDIDO VARCHAR2(10); -- FECHA CUANDO EL PEDIDO SE HIZO 
		V_FECHA_PEDIDO_COMPLETA VARCHAR2(30);
		V_FECHA_ENTREGAR VARCHAR2(30);	
		V_FECHA_ACTUAL VARCHAR2(30);
		V_MINUTOS_PASADOS NUMBER;
	BEGIN
		-- CONSULTA LA FECHA DEL PEDIDO
		SELECT DISTINCT TO_CHAR(PEDFECE, 'DD/MM/YYYY')
		INTO V_FECHA_PEDIDO
		FROM VEN0104 A
		INNER JOIN INV00018 B
			ON A.MESCOD = B.MESCOD
			AND B.MESNUMREQ  = PEDNUMDOC
			OR B.MESNUMREQ2 = PEDNUMDOC
			OR B.MESNUMREQ3 = PEDNUMDOC
			OR B.MESNUMREQ4 = PEDNUMDOC
		WHERE A.MESCOD = IN_MESA;		

		-- FECHA Y HORA DEL PEDIDO
		V_FECHA_PEDIDO_COMPLETA := V_FECHA_PEDIDO||' '||IN_HORA_PEDIDO;
		-- FECHA Y HORA QUE SE DEBERIA ENTREGAR EL PEDIDO EN MESA
		V_FECHA_ENTREGAR := TO_CHAR(TO_DATE(V_FECHA_PEDIDO_COMPLETA, 'DD/MM/YYYY HH24:MI:SS') + IN_TIEMPO_DEMORA / 1440,'DD/MM/YYYY HH24:MI:SS');
		-- FECHA DEL SISTEMA
		V_FECHA_ACTUAL := TO_CHAR(SYSDATE, 'DD/MM/YYYY HH24:MI:SS');

		-- SI LA FECHA DE ENTREGA ES MENOR A LA ACTUAL NO ESTA RETRASADA
		IF(TO_DATE(V_FECHA_ACTUAL,'DD/MM/YYYY HH24:MI:SS') < TO_DATE(V_FECHA_ENTREGAR,'DD/MM/YYYY HH24:MI:SS')) THEN 
			BEGIN
				RETURN 'SIN_RETRASO';
			END;
		ELSE
			BEGIN
				-- SE CALCULAS LOS MINUTOS DE RETRASO QUE TIENE EL PEDIDO
				SELECT (DIFERENCIA_HORAS * 60) + (DIFERENCIA_MINUTOS)
			    INTO V_MINUTOS_PASADOS
			    FROM (
				    SELECT FECHA_UNO,
				        FECHA_DOS,		        
				        TRUNC(MOD((FECHA_DOS - FECHA_UNO) * 24, 24)) DIFERENCIA_HORAS,
				        TRUNC(MOD((FECHA_DOS - FECHA_UNO) * (60 * 24), 60)) DIFERENCIA_MINUTOS,
				        TRUNC(MOD((FECHA_DOS - FECHA_UNO) * (60 * 60 * 24), 60)) DIFERENCIA_SEGUNDOS
				    FROM (
				        SELECT 
				            TO_DATE(V_FECHA_ENTREGAR, 'DD.MM.YYYY HH24:MI:SS') FECHA_UNO,
				            TO_DATE(V_FECHA_ACTUAL, 'DD.MM.YYYY HH24:MI:SS') FECHA_DOS
				        FROM DUAL
				        )
			    );

			    RETURN TO_CHAR(V_MINUTOS_PASADOS);
			END;
		END IF;
	END FN_TIEMPO_TRASCURRIDO_PEDIDO;

-- =============================================
-- REGISTRO DE CLIENTES
	PROCEDURE SP_ACOMER_REGISTRO_CLIENTE
	(
		IN_CODIGO_CLIENTE IN GEN0024.CLICOD%TYPE, 	-- CODIGO DEL CLIENTE QUE VA HACER REGISTRADO
		IN_NOMBRE_CLINETE IN GEN0024.CLINOM1%TYPE,	-- NOMBRE DLE CLIENTE QUE SE VA A REGISTRAR
		IN_DIRECCION_CLIENTE IN GEN0024.SUCTERDIR%TYPE, -- DIRECCION DEL CLIENTE QUE SE VA A REGISTRAR
		IN_CORREO_CLIENTE IN GEN0024.CLICNT%TYPE,		-- CORREO DEL CLIENTE QUE SE VA A REGISTRAR
		IN_TELEFONO_CLIENTE IN GEN0024.SUCTERTEL%TYPE,  -- TELEFONO DEL CLIENTE QUE SE VA A REGISTRAR
		IN_CIUDAD_CLIENTE IN GEN0024.CLIDIRENT%TYPE,		-- CIUDAD DE DIRECCION DEL CLIENTE
		OUT_CODIGO_MENSAJE OUT NUMBER					-- CODIGO DE MENSAJE	
	)
	AS
		V_CONTADOR NUMBER;
	BEGIN
		-- =============================================
		-- O: CLIENTE YA SE ENCUENTRA REGISTRADO EN LA BASE DE DATOS 
		-- 1: REGISTRO COMPLETADO
		-- 2: REGISTRO ERRONEO

		-- =============================================
		-- CONSULTA SI YA EXISTE UN REGISTRO CON EL CODIGO INGRESADO 
		SELECT COUNT(*)
		INTO V_CONTADOR
		FROM GEN0024
		WHERE CLICOD = IN_CODIGO_CLIENTE;

		-- SI HAY UN REGISTRO 
		IF(V_CONTADOR >= 1) THEN 
			BEGIN
				-- SE INDICA QUE EL CLEINTE YA HA SIDO REGISTRADO 
				OUT_CODIGO_MENSAJE := 0;			
			END;
		ELSE
			BEGIN
				INSERT INTO GEN0024(
					CLICOD, CLINOM1,
					SUCTERDIR, CLICNT,
					SUCTERTEL, CLIPAICOD,
					LIPCOD, SUCTERCOD,
					CLIDIRENT)
				VALUES(
					IN_CODIGO_CLIENTE, IN_NOMBRE_CLINETE,
					IN_DIRECCION_CLIENTE, IN_CORREO_CLIENTE,
					IN_TELEFONO_CLIENTE, '169',
					'01','01',
					IN_CIUDAD_CLIENTE);

				IF(SQL%ROWCOUNT = 1) THEN 
					-- INSERCION COMPLETADA
					OUT_CODIGO_MENSAJE := 1;
				ELSE 
					OUT_CODIGO_MENSAJE := 2;
				END IF;
			END;
		END IF;	
	END SP_ACOMER_REGISTRO_CLIENTE;

-- =============================================
-- CONSULTA EL NOMBRE DEL CLIENTE PARA LA FACTURA
	PROCEDURE SP_ACOMER_DATOS_CLIENTE
	( 
		IN_CEDULA_CLIENTE IN GEN0024.CLICOD%TYPE, -- CODIGO DEL CLIENTE
		OUT_NOMBRE_CLIENTE OUT VARCHAR2 -- NOMBRE DEL CLIENTE
	)
	AS
		V_CONTADOR NUMBER;  -- SABER SI EL CLIENTE EXISTE
	BEGIN
		-- EXISTENCIA DEL CLIENTE
		SELECT COUNT(*)
		INTO V_CONTADOR
		FROM GEN0024
		WHERE CLICOD = IN_CEDULA_CLIENTE;

		IF(V_CONTADOR = 1) THEN 
			-- CONSULTA EL NOMBRE DEL CLIENTE 
			SELECT UPPER(CLINOM1)
			INTO OUT_NOMBRE_CLIENTE
			FROM GEN0024
			WHERE CLICOD = IN_CEDULA_CLIENTE;

		ELSE
			OUT_NOMBRE_CLIENTE := 'SIN_REGISTRO';
		END IF;
		
	END SP_ACOMER_DATOS_CLIENTE;

-- =============================================
-- CODIGOS DE LOS RESTAURANTES
	PROCEDURE SP_ACOMER_CODIGO_CONTAINERS
	(
		OUT_CONTAINER1 OUT GEN0006.EMPCOD%TYPE,  -- CODIGO DEL CONTAINER 1
		OUT_CONTAINER2 OUT GEN0006.EMPCOD%TYPE,  -- CODIGO DEL CONTAINER 2
		OUT_CONTAINER3 OUT GEN0006.EMPCOD%TYPE,  -- CODIGO DEL CONTAINER 3
		OUT_CONTAINER4 OUT GEN0006.EMPCOD%TYPE   -- CODIGO DEL CONTAINER 4
	)
	AS
	BEGIN
		--SE ASGINAN LOS NOMBRES PERTENECIENTES A CADA CONTAINER O RESTAURANTE
		OUT_CONTAINER1 := PKG_CONTAINER1;
		OUT_CONTAINER2 := PKG_CONTAINER2;
		OUT_CONTAINER3 := PKG_CONTAINER3;
		OUT_CONTAINER4 := PKG_CONTAINER4;

	END SP_ACOMER_CODIGO_CONTAINERS;

-- =============================================
-- CANCELAR LO RESTANTE POR ENTREGAR
	PROCEDURE SP_ACOMER_PEDIDOS_CANCEL_REST
	(
		IN_CODIGO_MESA IN INV00018.MESCOD%TYPE  -- CODIGO DE LA MESA QU SE CANCELA
	)	
	AS
		ARRAY_CODIGOS_EMP TYPE_PEDIDOS_ARRAY; -- ARRAY DE LOS CODIGOS DE LOS CONTAINER
		ARRAY_NUMEROS_PED TYPE_PEDIDOS_ARRAY; -- ARRAY DE LOS NUMEROS DE LOS PEDIDOS
		V_MESA_UNIDA NUMBER;
	    V_CONTADOR_ENTREGADOS NUMBER := 0;
	BEGIN
		-- ==========================================
		-- LLENA EL ARRAY CON LOS CODIGOS DE LOS CONTAINER
		ARRAY_CODIGOS_EMP(1) := PKG_CONTAINER1;
		ARRAY_CODIGOS_EMP(2) := PKG_CONTAINER2;
		ARRAY_CODIGOS_EMP(3) := PKG_CONTAINER3;
		ARRAY_CODIGOS_EMP(4) := PKG_CONTAINER4;

		-- ==========================================
		-- SE LLENA EL ARRAY CON LOS NUMEROS DE PEDIDOS DE LA MESA
		SELECT MESNUMREQ, MESNUMREQ2,
			MESNUMREQ3, MESNUMREQ4
		INTO ARRAY_NUMEROS_PED(1), ARRAY_NUMEROS_PED(2),
			ARRAY_NUMEROS_PED(3), ARRAY_NUMEROS_PED(4)
		FROM INV00018
		WHERE MESCOD = CAST(IN_CODIGO_MESA AS NUMBER);

		-- ==========================================
		-- SE HACE EL CONTEO DE CUANTOS PEDIDOS HAN SIDO ENTREGADOS 
		FOR I IN ARRAY_NUMEROS_PED.FIRST..ARRAY_NUMEROS_PED.LAST
		LOOP
			BEGIN
				SELECT NVL(SUM(PEDUNI),0) - NVL(SUM(PEDCHECK),0) + V_CONTADOR_ENTREGADOS TOTAL_ENTREGADOS
				INTO V_CONTADOR_ENTREGADOS
				FROM VEN0004 A
				INNER JOIN VEN0104 B
				    ON A.PEDNRO = B.PEDNRO
				    AND B.PEDEMPC = CAST(ARRAY_CODIGOS_EMP(I) AS CHAR(13))
				    AND B.PEDNUMDOC = CAST(ARRAY_NUMEROS_PED(I) AS CHAR(10));						
			END;
		END LOOP;

		-- ==========================================
		-- IDENTIFICA SI ES UNA MESA QUE ESTA UNIDA
		BEGIN
			SELECT 1
			INTO V_MESA_UNIDA
			FROM UNIONMESA
			WHERE MESCOD = IN_CODIGO_MESA
			    OR MESCODUNI = IN_CODIGO_MESA;
		EXCEPTION
			WHEN NO_DATA_FOUND THEN 
				V_MESA_UNIDA := 0;
		END;

		-- ==========================================
		-- SI NO SE HAN ENTREGADO 
		IF(V_CONTADOR_ENTREGADOS = 0) THEN 
			BEGIN
				FOR I IN ARRAY_NUMEROS_PED.FIRST..ARRAY_NUMEROS_PED.LAST
				LOOP
					IF (ARRAY_NUMEROS_PED(I) <> ' ') THEN 
						-- ==========================================
						-- SE ACTUALIZA EL PEDIDO CANCELADO PARA CAMBIAR LUEGO DE TABLA
						UPDATE VEN0104
						SET PEDMODCOD = 'CANCEL'
						WHERE PEDEMPC = CAST(ARRAY_CODIGOS_EMP(I) AS CHAR(13))
				    		AND PEDNUMDOC = CAST(ARRAY_NUMEROS_PED(I) AS CHAR(10));

				    	-- SE ACTUALIZA EL DETALLE DEL PEDIDO CANCELADO 
				    	UPDATE VEN0004
						SET PEDSAL = 'C'
						WHERE PEDNRO IN (	SELECT DISTINCT A.PEDNRO 
											FROM VEN0004 A
											INNER JOIN VEN0104 B
												ON A.PEDNRO = B.PEDNRO
												AND B.PEDEMPC = CAST(ARRAY_CODIGOS_EMP(I) AS CHAR(13))
				    							AND B.PEDNUMDOC = CAST(ARRAY_NUMEROS_PED(I) AS CHAR(10))
				    					)
							AND PEDEMPC = CAST(ARRAY_CODIGOS_EMP(I) AS CHAR(13));

						-- ==========================================
				    	-- SE CAMBIA A LA TABLA CANCELADOS
				    	INSERT INTO PEDCAN
				    	SELECT * 
				    	FROM VEN0104
				    	WHERE PEDEMPC = CAST(ARRAY_CODIGOS_EMP(I) AS CHAR(13))
				    		AND PEDNUMDOC = CAST(ARRAY_NUMEROS_PED(I) AS CHAR(10));

				    	-- SE CAMBIA A LA TABLA CANCELADOS 
				    	INSERT INTO PEDDETCAN
				    	SELECT * 
				    	FROM VEN0004
				    	WHERE PEDNRO IN (	SELECT DISTINCT A.PEDNRO 
											FROM VEN0004 A
											INNER JOIN VEN0104 B
												ON A.PEDNRO = B.PEDNRO
												AND B.PEDEMPC = CAST(ARRAY_CODIGOS_EMP(I) AS CHAR(13))
				    							AND B.PEDNUMDOC = CAST(ARRAY_NUMEROS_PED(I) AS CHAR(10))
				    					)
							AND PEDEMPC = CAST(ARRAY_CODIGOS_EMP(I) AS CHAR(13));

						-- ==========================================
				    	-- SE ELIINAN LOS PLATOS QUE SE CANCELAN DE LA TABLA
				    	DELETE 
						FROM VEN0004
						WHERE PEDNRO IN (	SELECT DISTINCT A.PEDNRO 
											FROM VEN0004 A
											INNER JOIN VEN0104 B
												ON A.PEDNRO = B.PEDNRO
												AND B.PEDEMPC = CAST(ARRAY_CODIGOS_EMP(I) AS CHAR(13))
				    							AND B.PEDNUMDOC = CAST(ARRAY_NUMEROS_PED(I) AS CHAR(10))
				    					)
							AND PEDEMPC = CAST(ARRAY_CODIGOS_EMP(I) AS CHAR(13));
					END IF;
				END LOOP;	

				-- SI LA MESA ESTA UNIDA CON OTRA SE LIBERA DE PEDIDOS PERO QUEDA OCUPADA HASTA FACTURAR EL PEDIDO DE LA OTRA MESA
				IF(V_MESA_UNIDA = 1) THEN
					BEGIN	
						-- SE QUITAN TODOS LOS PEDIDOS QUE ESTAN LIGADOS A LA MESA 
						UPDATE INV00018
						SET MESDOCREQ = '',
							MESNUMREQ = '',
							MESNUMREQ2 = '',
							MESNUMREQ3 = '',
							MESNUMREQ4 = ''
						WHERE MESCOD = IN_CODIGO_MESA;
					END;
				ELSE
					BEGIN
						UPDATE INV00018
						SET MESNUMREQ = '',
							MESNUMREQ2 = '',
							MESNUMREQ3 = '',
							MESNUMREQ4 = '',
							MESUSUREQ = '',
							MESDOCREQ = '',
							MESESTADO = 'Activo',
							MESHORAPED = ''
						WHERE MESCOD = IN_CODIGO_MESA;
					END;
				END IF;		
			END;

		-- ==========================================
		-- SI EN LA MESA YA FUE ENTREGADO UNO O MAS PEDIDOS
		ELSE
			BEGIN
				FOR I IN ARRAY_NUMEROS_PED.FIRST..ARRAY_NUMEROS_PED.LAST
				LOOP
					-- CONTEO DE ENTREGAS EN ESE PEDIDO 
					SELECT SUM(A.PEDUNI) - SUM(PEDCHECK)
					INTO V_CONTADOR_ENTREGADOS
					FROM VEN0004 A
					INNER JOIN VEN0104 B
						ON A.PEDNRO = B.PEDNRO    
					WHERE B.MESCOD = IN_CODIGO_MESA
						AND B.PEDEMPC = CAST(ARRAY_CODIGOS_EMP(I) AS CHAR(13))
						AND B.PEDNUMDOC = CAST(ARRAY_NUMEROS_PED(I) AS CHAR(10));
					
					-- SI HAY ENTREGAS EN ESE EDIDO 
					IF(V_CONTADOR_ENTREGADOS > 0) THEN 
						DECLARE
							DATACURSOR1 VEN0004.CCOCOD%TYPE;
							DATACURSOR2 VEN0004.PEDUNI%TYPE;
							DATACURSOR3 VEN0004.PEDCHECK%TYPE;
							DATACURSOR4 VEN0004.PEDPROCOD%TYPE;						
							DATACURSOR5 NUMBER;
							DATACURSOR6 VEN0004.PEDNRO%TYPE;

							CURSOR CURSOR_1(IN_CURSOR2 IN CHAR, IN_CURSOR3 IN CHAR) IS
								SELECT A.CCOCOD, A.PEDUNI, A.PEDCHECK,
	    							A.PEDPROCOD, A.PEDUNI - A.PEDCHECK,
	    							A.PEDNRO
								FROM VEN0004 A
								INNER JOIN VEN0104 B
								    ON A.PEDNRO = B.PEDNRO    
								    AND B.PEDNUMDOC = IN_CURSOR2
								    AND B.PEDEMPC = IN_CURSOR3;
						BEGIN
							OPEN CURSOR_1(ARRAY_NUMEROS_PED(I), ARRAY_CODIGOS_EMP(I));
							FETCH CURSOR_1 INTO DATACURSOR1, DATACURSOR2, DATACURSOR3, DATACURSOR4, DATACURSOR5, DATACURSOR6;
							LOOP
								EXIT WHEN CURSOR_1%NOTFOUND;

								-- SI HAY UNA ENTREA EN EL PEDIDO 
								IF(DATACURSOR5 <> 0) THEN 
									DECLARE
										ARRAY_PLATOS TYPE_PEDIDOS_ARRAY;
										ARRAY_CANTIDAD TYPE_PEDIDOS_ARRAY;
										ARRAY_PUESTOS TYPE_PEDIDOS_ARRAY;
										V_CODIGO_MENSAJE NUMBER;
									BEGIN
										ARRAY_PLATOS(1) := DATACURSOR4;
										ARRAY_CANTIDAD(1) := DATACURSOR5;
										ARRAY_PUESTOS(1) := DATACURSOR1;

										SP_ACOMER_PEDIDOS_CANCEL(0,IN_CODIGO_MESA,ARRAY_PLATOS,
																					   ARRAY_CANTIDAD,ARRAY_PUESTOS,
																					   V_CODIGO_MENSAJE);
									END;
								-- SI ES CERO (NO SE HA ENTREGADO NADA DE ESE PEDIDOS)
								ELSE
									BEGIN
										DELETE 
										FROM VEN0004
										WHERE CCOCOD = DATACURSOR1
											AND PEDPROCOD = DATACURSOR4
											AND PEDNRO = DATACURSOR6
											AND PEDEMPC = CAST(ARRAY_CODIGOS_EMP(I) AS CHAR(13));										
									END;								
								END IF;
								FETCH CURSOR_1 INTO DATACURSOR1, DATACURSOR2, DATACURSOR3, DATACURSOR4, DATACURSOR5, DATACURSOR6;
							END LOOP;
							CLOSE CURSOR_1;
						END;
					ELSE 
						BEGIN
							-- SE ACTUALIZA EL PEDIDO 
							UPDATE VEN0104
							SET PEDMODCOD = 'CANCEL'
							WHERE PEDEMPC = CAST(ARRAY_CODIGOS_EMP(I) AS CHAR(13))
					    		AND PEDNUMDOC = CAST(ARRAY_NUMEROS_PED(I) AS CHAR(10));

					    	-- SE ACTUALIZA EL DETALLE DEL PEDIDO CANCELADO 
					    	UPDATE VEN0004
							SET PEDSAL = 'C'
							WHERE PEDNRO IN (	SELECT DISTINCT A.PEDNRO 
												FROM VEN0004 A
												INNER JOIN VEN0104 B
													ON A.PEDNRO = B.PEDNRO
													AND B.PEDEMPC = CAST(ARRAY_CODIGOS_EMP(I) AS CHAR(13))
					    							AND B.PEDNUMDOC = CAST(ARRAY_NUMEROS_PED(I) AS CHAR(10))
					    					)
								AND PEDEMPC = CAST(ARRAY_CODIGOS_EMP(I) AS CHAR(13));


							INSERT INTO PEDCAN
					    	SELECT * 
					    	FROM VEN0104
					    	WHERE PEDEMPC = CAST(ARRAY_CODIGOS_EMP(I) AS CHAR(13))
					    		AND PEDNUMDOC = CAST(ARRAY_NUMEROS_PED(I) AS CHAR(10));

					    	-- SE CAMBIA A LA TABLA CANCELADOS 
					    	INSERT INTO PEDDETCAN
					    	SELECT * 
					    	FROM VEN0004
					    	WHERE PEDNRO IN (	SELECT DISTINCT A.PEDNRO 
												FROM VEN0004 A
												INNER JOIN VEN0104 B
													ON A.PEDNRO = B.PEDNRO
													AND B.PEDEMPC = CAST(ARRAY_CODIGOS_EMP(I) AS CHAR(13))
					    							AND B.PEDNUMDOC = CAST(ARRAY_NUMEROS_PED(I) AS CHAR(10))
					    					)
								AND PEDEMPC = CAST(ARRAY_CODIGOS_EMP(I) AS CHAR(13));

						-- ==========================================
				    	-- SE ELIINAN LOS PLATOS QUE SE CANCELAN DE LA TABLA
				    	DELETE 
						FROM VEN0004
						WHERE PEDNRO IN (	SELECT DISTINCT A.PEDNRO 
											FROM VEN0004 A
											INNER JOIN VEN0104 B
												ON A.PEDNRO = B.PEDNRO
												AND B.PEDEMPC = CAST(ARRAY_CODIGOS_EMP(I) AS CHAR(13))
				    							AND B.PEDNUMDOC = CAST(ARRAY_NUMEROS_PED(I) AS CHAR(10))
				    					)
							AND PEDEMPC = CAST(ARRAY_CODIGOS_EMP(I) AS CHAR(13));
						END;
					END IF;
				END LOOP;
			END;
		END IF;
	END SP_ACOMER_PEDIDOS_CANCEL_REST;

-- =============================================
-- SABER SI LAS MESAS UNIDAS (ENTRE TODAS) TIENEN YA ENTREGADO UN PEDIDO
	PROCEDURE SP_ACOMER_PED_ENTREG_MESUNIDA	
	(
	    IN_MESA_PRINCIPAL IN NUMBER,
	    OUT_CODIGO_MENSAJE OUT NUMBER
	)
	AS
	    
	    ARRAY_CODIGOS_EMP PKG_ACOMER_PROCEDURES.TYPE_PEDIDOS_ARRAY; -- ARRAY DE LOS CODIGOS DE LOS CONTAINER
	    ARRAY_NUMEROS_PED PKG_ACOMER_PROCEDURES.TYPE_PEDIDOS_ARRAY; -- ARRAY DE LOS NUMEROS DE LOS PEDIDOS    
	    V_CONTADOR_ENTREGADOS NUMBER := 0;	  -- IDENTIFICAR SI YA SE HA ENTREGADO UN PEDIDO
	    -- CURSOR DE LAS MESAS QUE ESTAN UNIDAS A EL
	    DATACURSOR1 NUMBER;
	    CURSOR CURSOR1(IN_CURSOR1 NUMBER) IS
	        SELECT MESCODUNI
	        FROM UNIONMESA
	        WHERE MESCOD = IN_CURSOR1;
	BEGIN
	    OPEN CURSOR1(IN_MESA_PRINCIPAL);
	    FETCH CURSOR1 INTO DATACURSOR1;
	    LOOP        
	        EXIT WHEN CURSOR1%NOTFOUND;
	        
	                -- ==========================================
	        -- LLENA EL ARRAY CON LOS CODIGOS DE LOS CONTAINER
	        ARRAY_CODIGOS_EMP(1) := PKG_ACOMER_PROCEDURES.PKG_CONTAINER1;
	        ARRAY_CODIGOS_EMP(2) := PKG_ACOMER_PROCEDURES.PKG_CONTAINER2;
	        ARRAY_CODIGOS_EMP(3) := PKG_ACOMER_PROCEDURES.PKG_CONTAINER3;
	        ARRAY_CODIGOS_EMP(4) := PKG_ACOMER_PROCEDURES.PKG_CONTAINER4;
	    
	        -- ==========================================
	        -- SE LLENA EL ARRAY CON LOS NUMEROS DE PEDIDOS DE LA MESA
	        SELECT MESNUMREQ, MESNUMREQ2,
	            MESNUMREQ3, MESNUMREQ4
	        INTO ARRAY_NUMEROS_PED(1), ARRAY_NUMEROS_PED(2),
	            ARRAY_NUMEROS_PED(3), ARRAY_NUMEROS_PED(4)
	        FROM INV00018
	        WHERE MESCOD = DATACURSOR1;
	    
	        -- ==========================================
	        -- SE HACE EL CONTEO DE CUANTOS PEDIDOS HAN SIDO ENTREGADOS 
	        FOR I IN ARRAY_NUMEROS_PED.FIRST..ARRAY_NUMEROS_PED.LAST
	        LOOP
	            BEGIN
	                SELECT NVL(SUM(PEDUNI),0) - NVL(SUM(PEDCHECK),0) + V_CONTADOR_ENTREGADOS TOTAL_ENTREGADOS
	                INTO V_CONTADOR_ENTREGADOS
	                FROM VEN0004 A
	                INNER JOIN VEN0104 B
	                    ON A.PEDNRO = B.PEDNRO
	                    AND B.PEDEMPC = CAST(ARRAY_CODIGOS_EMP(I) AS CHAR(13))
	                    AND B.PEDNUMDOC = CAST(ARRAY_NUMEROS_PED(I) AS CHAR(10));						
	            END;
	        END LOOP;

	        
	        FETCH CURSOR1 INTO DATACURSOR1;
	    END LOOP;
	    
	    -- ==========================================
	    -- LLENA EL ARRAY CON LOS CODIGOS DE LOS CONTAINER
	    ARRAY_CODIGOS_EMP(1) := PKG_ACOMER_PROCEDURES.PKG_CONTAINER1;
	    ARRAY_CODIGOS_EMP(2) := PKG_ACOMER_PROCEDURES.PKG_CONTAINER2;
	    ARRAY_CODIGOS_EMP(3) := PKG_ACOMER_PROCEDURES.PKG_CONTAINER3;
	    ARRAY_CODIGOS_EMP(4) := PKG_ACOMER_PROCEDURES.PKG_CONTAINER4;

	    -- ==========================================
	    -- SE LLENA EL ARRAY CON LOS NUMEROS DE PEDIDOS DE LA MESA
	    SELECT MESNUMREQ, MESNUMREQ2,
	        MESNUMREQ3, MESNUMREQ4
	    INTO ARRAY_NUMEROS_PED(1), ARRAY_NUMEROS_PED(2),
	        ARRAY_NUMEROS_PED(3), ARRAY_NUMEROS_PED(4)
	    FROM INV00018
	    WHERE MESCOD = CAST(IN_MESA_PRINCIPAL AS NUMBER);

	    -- ==========================================
	    -- SE HACE EL CONTEO DE CUANTOS PEDIDOS HAN SIDO ENTREGADOS 
	    FOR I IN ARRAY_NUMEROS_PED.FIRST..ARRAY_NUMEROS_PED.LAST
	    LOOP
	        BEGIN
	            SELECT NVL(SUM(PEDUNI),0) - NVL(SUM(PEDCHECK),0) + V_CONTADOR_ENTREGADOS TOTAL_ENTREGADOS
	            INTO V_CONTADOR_ENTREGADOS
	            FROM VEN0004 A
	            INNER JOIN VEN0104 B
	                ON A.PEDNRO = B.PEDNRO
	                AND B.PEDEMPC = CAST(ARRAY_CODIGOS_EMP(I) AS CHAR(13))
	                AND B.PEDNUMDOC = CAST(ARRAY_NUMEROS_PED(I) AS CHAR(10));						
	        END;
	    END LOOP;
	    
	    IF(V_CONTADOR_ENTREGADOS <> 0) THEN 
	        OUT_CODIGO_MENSAJE := 1;
	    ELSE
	        OUT_CODIGO_MENSAJE := 0;
	    END IF;
	END SP_ACOMER_PED_ENTREG_MESUNIDA;   

-- =============================================
-- PONER EL ESTADO DEL PEDIDO COMO ENTREGAGO
	PROCEDURE SP_ACOMER_ENTREGAR_PEDIDO_MESA
	(
		IN_PUESTOS IN TYPE_PEDIDOS_ARRAY, 				-- 
		IN_PLATOS IN TYPE_PEDIDOS_ARRAY,				--
		IN_NUMERO_DOCUMENTO IN VEN0104.PEDNUMDOC%TYPE,  -- NUMERO DE DOCUMENTO
		IN_CODIGO_EMPRESA IN VEN0004.PEDEMPC%TYPE 		-- CODIGO DE LA EMPRESA

	)
	AS 	
		V_PEDNRO VEN0104.PEDNRO%TYPE;
		V_FALTANTES VEN0004.PEDCHECK%TYPE;
	BEGIN
		FOR I IN IN_PUESTOS.FIRST..IN_PUESTOS.LAST
		LOOP
			SELECT DISTINCT A.PEDCHECK, A.PEDNRO
            INTO V_FALTANTES, V_PEDNRO
            FROM VEN0004 A
            INNER JOIN VEN0104 B
                ON A.PEDNRO = B.PEDNRO
                AND B.PEDNUMDOC = IN_NUMERO_DOCUMENTO
            WHERE A.PEDEMPC = IN_CODIGO_EMPRESA
                AND A.CCOCOD = CAST(IN_PUESTOS(I) AS CHAR(13))
                AND A.PEDPROCOD = CAST(IN_PLATOS(I) AS CHAR(20));

            IF(V_FALTANTES = 0) THEN 
                UPDATE VEN0004
                SET PEDSAL = 'E'
                WHERE PEDNRO = V_PEDNRO
                    AND PEDEMPC = IN_CODIGO_EMPRESA;
            END IF;
			
		END LOOP;
	END SP_ACOMER_ENTREGAR_PEDIDO_MESA;    

-- =============================================
-- HISTORIAL DE PEDIDOS EN COCINA YA HECHOS
	PROCEDURE SP_ACOMER_HISTORIAL_COCINA
	(
		IN_CODIGO_COCINERO IN GEN0011.TERCOD%TYPE, -- CODIGO DEL COCINERO QUE TERMINA EL PEDIDO
		IN_PLATO IN VEN0001.PRODES%TYPE,		   -- CODIGO DEL PLATO QUE TERMINA
		IN_CANTIDAD	IN VEN0004.PEDUNI%TYPE		   -- CANTIDAD DEL PLATO QUE HA TERMINADO 
	)
	AS
		V_CODIGO_PLATO VEN0001.PROCOD%TYPE;			-- CODIGO DEL PLATO
		V_CODIGO_EMPRESA SEG00011.USUEMPC%TYPE;		-- EMPRESA A LA QUE PERTENECE EL COCINERO
	BEGIN
		-- ============================
		-- CONSULTA EL CODIGO DEL PLATO 
		SELECT PROCOD
		INTO V_CODIGO_PLATO
		FROM VEN0001
		WHERE PRODES = IN_PLATO;

		-- ============================
		-- CONSULTA EL CODIGO DE LA EMPRESA A LA Q PERTENECE EL 
		SELECT VENEMPC
		INTO V_CODIGO_EMPRESA
		FROM VEN0001
		WHERE PRODES = IN_PLATO;

		-- ============================
		-- CONSULTA EL CODIGO DEL PLATO 
		INSERT INTO HISTCOCINA (
			CODCOCI, EMPRESA,
			PLATO, CANTIDAD,
			FECHA, HORAFIN,
			ESTADO)
		VALUES(
			IN_CODIGO_COCINERO, V_CODIGO_EMPRESA,
			V_CODIGO_PLATO, IN_CANTIDAD,
			TO_CHAR(SYSDATE,'DD/MM/YYYY'), TO_CHAR(SYSDATE,'HH24:MI:SS'),
			'T');

		COMMIT;
	END SP_ACOMER_HISTORIAL_COCINA;    

-- =============================================
-- CONSULTA EL HISTORIAL EN COCINA
	PROCEDURE SP_ACOMER_CONSULTA_HISTCOCINA
	(
		IN_CODIGO_COCINERO IN GEN0011.TERCOD%TYPE,
		OUT_CURSOR OUT SYS_REFCURSOR -- CRUSR CON LOS DATOS DEL HISTORIAL 
	)
	AS 
		V_EMPRESA_COCINERO SEG0001.EMPCOD%TYPE; -- EMPRESA A LA QUE PERTENECE EL COCINERO 
		V_CONTADOR NUMBER;
	BEGIN
		/*SELECT EMPCOD
		INTO V_EMPRESA_COCINERO
		FROM SEG0001
		WHERE USUCED = IN_CODIGO_COCINERO;*/

		V_EMPRESA_COCINERO := '901.023.461-1';

		-- SABER CUANTOS DATOS HAY EN HISTORIAL
		SELECT COUNT(*)
		INTO V_CONTADOR
		FROM HISTCOCINA A
		INNER JOIN VEN0001 B
			ON A.PLATO = B.PROCOD
		WHERE EMPRESA = V_EMPRESA_COCINERO
		ORDER BY FECHA, HORAFIN;


		IF(V_CONTADOR = 0) THEN 
			BEGIN
				OPEN OUT_CURSOR FOR
					SELECT 'SIN_DATOS' PLATO, 'SIN_DATOS' CANTIDAD,
					    'SIN_DATOS' FECHA, 'SIN_DATOS' HORAFIN 
					FROM DUAL;
			END;

		ELSE
			BEGIN
				OPEN OUT_CURSOR FOR
					SELECT PRODES PLATO, CANTIDAD,
					    FECHA, HORAFIN 
					FROM HISTCOCINA A
					INNER JOIN VEN0001 B
						ON A.PLATO = B.PROCOD
					WHERE EMPRESA = V_EMPRESA_COCINERO
					ORDER BY FECHA, HORAFIN;
			END;
		END IF;
	END SP_ACOMER_CONSULTA_HISTCOCINA;     

-- =============================================
-- CONSULTA EL ROL 
	PROCEDURE SP_ACOMER_CONSULTA_ROL
	(
		IN_CEDULA IN TAB_REL_ROL.TERCOD%TYPE, -- CODIGO DE QUIEN INICIA SESION
		OUT_PERFIL OUT VARCHAR2				  -- PERFIL QUE POSEE QUIEN INICIA SESION
	)
	AS
	BEGIN
	-- CONSULTA EL ROL DE QUIEN INGRESA
		SELECT NOMBREROL
		INTO OUT_PERFIL
		FROM TAB_REL_ROL A
		INNER JOIN TAB_ROLES B
			ON A.IDROL = B.IDROL
		WHERE TERCOD = IN_CEDULA;
	END SP_ACOMER_CONSULTA_ROL;   

-- =============================================
-- NOMBRE DE LA COCINA
	PROCEDURE SP_ACOMER_NOMBRE_COCINAS
	(
		IN_CEDULA IN TAB_REL_ROL.TERCOD%TYPE,			-- CEDULA DE QUIEN INCIIA
		OUT_NOMBRE_REST OUT GEN0006.EMPNOM%TYPE  		-- NOMBRE DE LA EMPRESA A LA QUE PERTENECE
	)
	AS
	BEGIN
		-- CONSULTA EL NOMBRE DE LA EMPRESA A LA QUE PERTENECE
		SELECT TRIM (EMPNOM)
		INTO OUT_NOMBRE_REST
		FROM TAB_REL_ROL A
		INNER JOIN GEN0006 B
			ON A.EMPCOD = B.EMPCOD
		WHERE A.TERCOD = IN_CEDULA;
	END SP_ACOMER_NOMBRE_COCINAS;
END; 